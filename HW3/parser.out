Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Unused terminals:

    UMINUS
    NEWLINE
    SCOMMENT

Grammar

Rule 0     S' -> pgm
Rule 1     pgm -> stmt_seq
Rule 2     stmt_seq -> stmt stmt_seq
Rule 3     stmt_seq -> stmt
Rule 4     stmt -> assign_stmt
Rule 5     stmt -> print_stmt
Rule 6     stmt -> block_stmt
Rule 7     stmt -> if_stmt
Rule 8     stmt -> while_stmt
Rule 9     assign_stmt -> IDENTIFIER EQUALS rhs SEMICOLON
Rule 10    print_stmt -> PRINT LPAREN arith_expr RPAREN SEMICOLON
Rule 11    block_stmt -> LBRACE stmt_seq RBRACE
Rule 12    if_stmt -> IF arith_expr THEN stmt ELSE stmt
Rule 13    if_stmt -> IF arith_expr THEN stmt
Rule 14    while_stmt -> WHILE arith_expr DO stmt
Rule 15    rhs -> INPUT LPAREN RPAREN
Rule 16    rhs -> arith_expr
Rule 17    arith_expr -> arith_expr PLUS arith_expr
Rule 18    arith_expr -> arith_expr MINUS arith_expr
Rule 19    arith_expr -> arith_expr STAR arith_expr
Rule 20    arith_expr -> arith_expr DIV arith_expr
Rule 21    arith_expr -> arith_expr MOD arith_expr
Rule 22    arith_expr -> arith_expr AND arith_expr
Rule 23    arith_expr -> arith_expr OR arith_expr
Rule 24    arith_expr -> arith_expr EQUAL arith_expr
Rule 25    arith_expr -> arith_expr NEQUAL arith_expr
Rule 26    arith_expr -> arith_expr LTHAN arith_expr
Rule 27    arith_expr -> arith_expr LTHANEQ arith_expr
Rule 28    arith_expr -> arith_expr GTHAN arith_expr
Rule 29    arith_expr -> arith_expr GTHANEQ arith_expr
Rule 30    arith_expr -> NOT arith_expr
Rule 31    arith_expr -> MINUS arith_expr
Rule 32    arith_expr -> LPAREN arith_expr RPAREN
Rule 33    arith_expr -> INTCONST
Rule 34    arith_expr -> IDENTIFIER

Terminals, with rules where they appear

AND                  : 22
DIV                  : 20
DO                   : 14
ELSE                 : 12
EQUAL                : 24
EQUALS               : 9
GTHAN                : 28
GTHANEQ              : 29
IDENTIFIER           : 9 34
IF                   : 12 13
INPUT                : 15
INTCONST             : 33
LBRACE               : 11
LPAREN               : 10 15 32
LTHAN                : 26
LTHANEQ              : 27
MINUS                : 18 31
MOD                  : 21
NEQUAL               : 25
NEWLINE              : 
NOT                  : 30
OR                   : 23
PLUS                 : 17
PRINT                : 10
RBRACE               : 11
RPAREN               : 10 15 32
SCOMMENT             : 
SEMICOLON            : 9 10
STAR                 : 19
THEN                 : 12 13
UMINUS               : 
WHILE                : 14
error                : 

Nonterminals, with rules where they appear

arith_expr           : 10 12 13 14 16 17 17 18 18 19 19 20 20 21 21 22 22 23 23 24 24 25 25 26 26 27 27 28 28 29 29 30 31 32
assign_stmt          : 4
block_stmt           : 6
if_stmt              : 7
pgm                  : 0
print_stmt           : 5
rhs                  : 9
stmt                 : 2 3 12 12 13 14
stmt_seq             : 1 2 11
while_stmt           : 8

Parsing method: LALR

state 0

    (0) S' -> . pgm
    (1) pgm -> . stmt_seq
    (2) stmt_seq -> . stmt stmt_seq
    (3) stmt_seq -> . stmt
    (4) stmt -> . assign_stmt
    (5) stmt -> . print_stmt
    (6) stmt -> . block_stmt
    (7) stmt -> . if_stmt
    (8) stmt -> . while_stmt
    (9) assign_stmt -> . IDENTIFIER EQUALS rhs SEMICOLON
    (10) print_stmt -> . PRINT LPAREN arith_expr RPAREN SEMICOLON
    (11) block_stmt -> . LBRACE stmt_seq RBRACE
    (12) if_stmt -> . IF arith_expr THEN stmt ELSE stmt
    (13) if_stmt -> . IF arith_expr THEN stmt
    (14) while_stmt -> . WHILE arith_expr DO stmt

    IDENTIFIER      shift and go to state 6
    PRINT           shift and go to state 3
    LBRACE          shift and go to state 10
    IF              shift and go to state 9
    WHILE           shift and go to state 2

    if_stmt                        shift and go to state 11
    stmt_seq                       shift and go to state 12
    print_stmt                     shift and go to state 7
    pgm                            shift and go to state 1
    block_stmt                     shift and go to state 4
    assign_stmt                    shift and go to state 5
    while_stmt                     shift and go to state 13
    stmt                           shift and go to state 8

state 1

    (0) S' -> pgm .



state 2

    (14) while_stmt -> WHILE . arith_expr DO stmt
    (17) arith_expr -> . arith_expr PLUS arith_expr
    (18) arith_expr -> . arith_expr MINUS arith_expr
    (19) arith_expr -> . arith_expr STAR arith_expr
    (20) arith_expr -> . arith_expr DIV arith_expr
    (21) arith_expr -> . arith_expr MOD arith_expr
    (22) arith_expr -> . arith_expr AND arith_expr
    (23) arith_expr -> . arith_expr OR arith_expr
    (24) arith_expr -> . arith_expr EQUAL arith_expr
    (25) arith_expr -> . arith_expr NEQUAL arith_expr
    (26) arith_expr -> . arith_expr LTHAN arith_expr
    (27) arith_expr -> . arith_expr LTHANEQ arith_expr
    (28) arith_expr -> . arith_expr GTHAN arith_expr
    (29) arith_expr -> . arith_expr GTHANEQ arith_expr
    (30) arith_expr -> . NOT arith_expr
    (31) arith_expr -> . MINUS arith_expr
    (32) arith_expr -> . LPAREN arith_expr RPAREN
    (33) arith_expr -> . INTCONST
    (34) arith_expr -> . IDENTIFIER

    NOT             shift and go to state 19
    MINUS           shift and go to state 14
    LPAREN          shift and go to state 16
    INTCONST        shift and go to state 17
    IDENTIFIER      shift and go to state 15

    arith_expr                     shift and go to state 18

state 3

    (10) print_stmt -> PRINT . LPAREN arith_expr RPAREN SEMICOLON

    LPAREN          shift and go to state 20


state 4

    (6) stmt -> block_stmt .

    IDENTIFIER      reduce using rule 6 (stmt -> block_stmt .)
    PRINT           reduce using rule 6 (stmt -> block_stmt .)
    LBRACE          reduce using rule 6 (stmt -> block_stmt .)
    IF              reduce using rule 6 (stmt -> block_stmt .)
    WHILE           reduce using rule 6 (stmt -> block_stmt .)
    $end            reduce using rule 6 (stmt -> block_stmt .)
    RBRACE          reduce using rule 6 (stmt -> block_stmt .)
    ELSE            reduce using rule 6 (stmt -> block_stmt .)


state 5

    (4) stmt -> assign_stmt .

    IDENTIFIER      reduce using rule 4 (stmt -> assign_stmt .)
    PRINT           reduce using rule 4 (stmt -> assign_stmt .)
    LBRACE          reduce using rule 4 (stmt -> assign_stmt .)
    IF              reduce using rule 4 (stmt -> assign_stmt .)
    WHILE           reduce using rule 4 (stmt -> assign_stmt .)
    $end            reduce using rule 4 (stmt -> assign_stmt .)
    RBRACE          reduce using rule 4 (stmt -> assign_stmt .)
    ELSE            reduce using rule 4 (stmt -> assign_stmt .)


state 6

    (9) assign_stmt -> IDENTIFIER . EQUALS rhs SEMICOLON

    EQUALS          shift and go to state 21


state 7

    (5) stmt -> print_stmt .

    IDENTIFIER      reduce using rule 5 (stmt -> print_stmt .)
    PRINT           reduce using rule 5 (stmt -> print_stmt .)
    LBRACE          reduce using rule 5 (stmt -> print_stmt .)
    IF              reduce using rule 5 (stmt -> print_stmt .)
    WHILE           reduce using rule 5 (stmt -> print_stmt .)
    $end            reduce using rule 5 (stmt -> print_stmt .)
    RBRACE          reduce using rule 5 (stmt -> print_stmt .)
    ELSE            reduce using rule 5 (stmt -> print_stmt .)


state 8

    (2) stmt_seq -> stmt . stmt_seq
    (3) stmt_seq -> stmt .
    (2) stmt_seq -> . stmt stmt_seq
    (3) stmt_seq -> . stmt
    (4) stmt -> . assign_stmt
    (5) stmt -> . print_stmt
    (6) stmt -> . block_stmt
    (7) stmt -> . if_stmt
    (8) stmt -> . while_stmt
    (9) assign_stmt -> . IDENTIFIER EQUALS rhs SEMICOLON
    (10) print_stmt -> . PRINT LPAREN arith_expr RPAREN SEMICOLON
    (11) block_stmt -> . LBRACE stmt_seq RBRACE
    (12) if_stmt -> . IF arith_expr THEN stmt ELSE stmt
    (13) if_stmt -> . IF arith_expr THEN stmt
    (14) while_stmt -> . WHILE arith_expr DO stmt

    $end            reduce using rule 3 (stmt_seq -> stmt .)
    RBRACE          reduce using rule 3 (stmt_seq -> stmt .)
    IDENTIFIER      shift and go to state 6
    PRINT           shift and go to state 3
    LBRACE          shift and go to state 10
    IF              shift and go to state 9
    WHILE           shift and go to state 2

    if_stmt                        shift and go to state 11
    stmt_seq                       shift and go to state 22
    print_stmt                     shift and go to state 7
    block_stmt                     shift and go to state 4
    assign_stmt                    shift and go to state 5
    while_stmt                     shift and go to state 13
    stmt                           shift and go to state 8

state 9

    (12) if_stmt -> IF . arith_expr THEN stmt ELSE stmt
    (13) if_stmt -> IF . arith_expr THEN stmt
    (17) arith_expr -> . arith_expr PLUS arith_expr
    (18) arith_expr -> . arith_expr MINUS arith_expr
    (19) arith_expr -> . arith_expr STAR arith_expr
    (20) arith_expr -> . arith_expr DIV arith_expr
    (21) arith_expr -> . arith_expr MOD arith_expr
    (22) arith_expr -> . arith_expr AND arith_expr
    (23) arith_expr -> . arith_expr OR arith_expr
    (24) arith_expr -> . arith_expr EQUAL arith_expr
    (25) arith_expr -> . arith_expr NEQUAL arith_expr
    (26) arith_expr -> . arith_expr LTHAN arith_expr
    (27) arith_expr -> . arith_expr LTHANEQ arith_expr
    (28) arith_expr -> . arith_expr GTHAN arith_expr
    (29) arith_expr -> . arith_expr GTHANEQ arith_expr
    (30) arith_expr -> . NOT arith_expr
    (31) arith_expr -> . MINUS arith_expr
    (32) arith_expr -> . LPAREN arith_expr RPAREN
    (33) arith_expr -> . INTCONST
    (34) arith_expr -> . IDENTIFIER

    NOT             shift and go to state 19
    MINUS           shift and go to state 14
    LPAREN          shift and go to state 16
    INTCONST        shift and go to state 17
    IDENTIFIER      shift and go to state 15

    arith_expr                     shift and go to state 23

state 10

    (11) block_stmt -> LBRACE . stmt_seq RBRACE
    (2) stmt_seq -> . stmt stmt_seq
    (3) stmt_seq -> . stmt
    (4) stmt -> . assign_stmt
    (5) stmt -> . print_stmt
    (6) stmt -> . block_stmt
    (7) stmt -> . if_stmt
    (8) stmt -> . while_stmt
    (9) assign_stmt -> . IDENTIFIER EQUALS rhs SEMICOLON
    (10) print_stmt -> . PRINT LPAREN arith_expr RPAREN SEMICOLON
    (11) block_stmt -> . LBRACE stmt_seq RBRACE
    (12) if_stmt -> . IF arith_expr THEN stmt ELSE stmt
    (13) if_stmt -> . IF arith_expr THEN stmt
    (14) while_stmt -> . WHILE arith_expr DO stmt

    IDENTIFIER      shift and go to state 6
    PRINT           shift and go to state 3
    LBRACE          shift and go to state 10
    IF              shift and go to state 9
    WHILE           shift and go to state 2

    if_stmt                        shift and go to state 11
    stmt_seq                       shift and go to state 24
    print_stmt                     shift and go to state 7
    block_stmt                     shift and go to state 4
    assign_stmt                    shift and go to state 5
    while_stmt                     shift and go to state 13
    stmt                           shift and go to state 8

state 11

    (7) stmt -> if_stmt .

    IDENTIFIER      reduce using rule 7 (stmt -> if_stmt .)
    PRINT           reduce using rule 7 (stmt -> if_stmt .)
    LBRACE          reduce using rule 7 (stmt -> if_stmt .)
    IF              reduce using rule 7 (stmt -> if_stmt .)
    WHILE           reduce using rule 7 (stmt -> if_stmt .)
    $end            reduce using rule 7 (stmt -> if_stmt .)
    RBRACE          reduce using rule 7 (stmt -> if_stmt .)
    ELSE            reduce using rule 7 (stmt -> if_stmt .)


state 12

    (1) pgm -> stmt_seq .

    $end            reduce using rule 1 (pgm -> stmt_seq .)


state 13

    (8) stmt -> while_stmt .

    IDENTIFIER      reduce using rule 8 (stmt -> while_stmt .)
    PRINT           reduce using rule 8 (stmt -> while_stmt .)
    LBRACE          reduce using rule 8 (stmt -> while_stmt .)
    IF              reduce using rule 8 (stmt -> while_stmt .)
    WHILE           reduce using rule 8 (stmt -> while_stmt .)
    $end            reduce using rule 8 (stmt -> while_stmt .)
    RBRACE          reduce using rule 8 (stmt -> while_stmt .)
    ELSE            reduce using rule 8 (stmt -> while_stmt .)


state 14

    (31) arith_expr -> MINUS . arith_expr
    (17) arith_expr -> . arith_expr PLUS arith_expr
    (18) arith_expr -> . arith_expr MINUS arith_expr
    (19) arith_expr -> . arith_expr STAR arith_expr
    (20) arith_expr -> . arith_expr DIV arith_expr
    (21) arith_expr -> . arith_expr MOD arith_expr
    (22) arith_expr -> . arith_expr AND arith_expr
    (23) arith_expr -> . arith_expr OR arith_expr
    (24) arith_expr -> . arith_expr EQUAL arith_expr
    (25) arith_expr -> . arith_expr NEQUAL arith_expr
    (26) arith_expr -> . arith_expr LTHAN arith_expr
    (27) arith_expr -> . arith_expr LTHANEQ arith_expr
    (28) arith_expr -> . arith_expr GTHAN arith_expr
    (29) arith_expr -> . arith_expr GTHANEQ arith_expr
    (30) arith_expr -> . NOT arith_expr
    (31) arith_expr -> . MINUS arith_expr
    (32) arith_expr -> . LPAREN arith_expr RPAREN
    (33) arith_expr -> . INTCONST
    (34) arith_expr -> . IDENTIFIER

    NOT             shift and go to state 19
    MINUS           shift and go to state 14
    LPAREN          shift and go to state 16
    INTCONST        shift and go to state 17
    IDENTIFIER      shift and go to state 15

    arith_expr                     shift and go to state 25

state 15

    (34) arith_expr -> IDENTIFIER .

    PLUS            reduce using rule 34 (arith_expr -> IDENTIFIER .)
    MINUS           reduce using rule 34 (arith_expr -> IDENTIFIER .)
    STAR            reduce using rule 34 (arith_expr -> IDENTIFIER .)
    DIV             reduce using rule 34 (arith_expr -> IDENTIFIER .)
    MOD             reduce using rule 34 (arith_expr -> IDENTIFIER .)
    AND             reduce using rule 34 (arith_expr -> IDENTIFIER .)
    OR              reduce using rule 34 (arith_expr -> IDENTIFIER .)
    EQUAL           reduce using rule 34 (arith_expr -> IDENTIFIER .)
    NEQUAL          reduce using rule 34 (arith_expr -> IDENTIFIER .)
    LTHAN           reduce using rule 34 (arith_expr -> IDENTIFIER .)
    LTHANEQ         reduce using rule 34 (arith_expr -> IDENTIFIER .)
    GTHAN           reduce using rule 34 (arith_expr -> IDENTIFIER .)
    GTHANEQ         reduce using rule 34 (arith_expr -> IDENTIFIER .)
    DO              reduce using rule 34 (arith_expr -> IDENTIFIER .)
    THEN            reduce using rule 34 (arith_expr -> IDENTIFIER .)
    RPAREN          reduce using rule 34 (arith_expr -> IDENTIFIER .)
    SEMICOLON       reduce using rule 34 (arith_expr -> IDENTIFIER .)


state 16

    (32) arith_expr -> LPAREN . arith_expr RPAREN
    (17) arith_expr -> . arith_expr PLUS arith_expr
    (18) arith_expr -> . arith_expr MINUS arith_expr
    (19) arith_expr -> . arith_expr STAR arith_expr
    (20) arith_expr -> . arith_expr DIV arith_expr
    (21) arith_expr -> . arith_expr MOD arith_expr
    (22) arith_expr -> . arith_expr AND arith_expr
    (23) arith_expr -> . arith_expr OR arith_expr
    (24) arith_expr -> . arith_expr EQUAL arith_expr
    (25) arith_expr -> . arith_expr NEQUAL arith_expr
    (26) arith_expr -> . arith_expr LTHAN arith_expr
    (27) arith_expr -> . arith_expr LTHANEQ arith_expr
    (28) arith_expr -> . arith_expr GTHAN arith_expr
    (29) arith_expr -> . arith_expr GTHANEQ arith_expr
    (30) arith_expr -> . NOT arith_expr
    (31) arith_expr -> . MINUS arith_expr
    (32) arith_expr -> . LPAREN arith_expr RPAREN
    (33) arith_expr -> . INTCONST
    (34) arith_expr -> . IDENTIFIER

    NOT             shift and go to state 19
    MINUS           shift and go to state 14
    LPAREN          shift and go to state 16
    INTCONST        shift and go to state 17
    IDENTIFIER      shift and go to state 15

    arith_expr                     shift and go to state 26

state 17

    (33) arith_expr -> INTCONST .

    PLUS            reduce using rule 33 (arith_expr -> INTCONST .)
    MINUS           reduce using rule 33 (arith_expr -> INTCONST .)
    STAR            reduce using rule 33 (arith_expr -> INTCONST .)
    DIV             reduce using rule 33 (arith_expr -> INTCONST .)
    MOD             reduce using rule 33 (arith_expr -> INTCONST .)
    AND             reduce using rule 33 (arith_expr -> INTCONST .)
    OR              reduce using rule 33 (arith_expr -> INTCONST .)
    EQUAL           reduce using rule 33 (arith_expr -> INTCONST .)
    NEQUAL          reduce using rule 33 (arith_expr -> INTCONST .)
    LTHAN           reduce using rule 33 (arith_expr -> INTCONST .)
    LTHANEQ         reduce using rule 33 (arith_expr -> INTCONST .)
    GTHAN           reduce using rule 33 (arith_expr -> INTCONST .)
    GTHANEQ         reduce using rule 33 (arith_expr -> INTCONST .)
    DO              reduce using rule 33 (arith_expr -> INTCONST .)
    THEN            reduce using rule 33 (arith_expr -> INTCONST .)
    RPAREN          reduce using rule 33 (arith_expr -> INTCONST .)
    SEMICOLON       reduce using rule 33 (arith_expr -> INTCONST .)


state 18

    (14) while_stmt -> WHILE arith_expr . DO stmt
    (17) arith_expr -> arith_expr . PLUS arith_expr
    (18) arith_expr -> arith_expr . MINUS arith_expr
    (19) arith_expr -> arith_expr . STAR arith_expr
    (20) arith_expr -> arith_expr . DIV arith_expr
    (21) arith_expr -> arith_expr . MOD arith_expr
    (22) arith_expr -> arith_expr . AND arith_expr
    (23) arith_expr -> arith_expr . OR arith_expr
    (24) arith_expr -> arith_expr . EQUAL arith_expr
    (25) arith_expr -> arith_expr . NEQUAL arith_expr
    (26) arith_expr -> arith_expr . LTHAN arith_expr
    (27) arith_expr -> arith_expr . LTHANEQ arith_expr
    (28) arith_expr -> arith_expr . GTHAN arith_expr
    (29) arith_expr -> arith_expr . GTHANEQ arith_expr

    DO              shift and go to state 28
    PLUS            shift and go to state 35
    MINUS           shift and go to state 39
    STAR            shift and go to state 29
    DIV             shift and go to state 37
    MOD             shift and go to state 40
    AND             shift and go to state 27
    OR              shift and go to state 33
    EQUAL           shift and go to state 32
    NEQUAL          shift and go to state 31
    LTHAN           shift and go to state 34
    LTHANEQ         shift and go to state 36
    GTHAN           shift and go to state 30
    GTHANEQ         shift and go to state 38


state 19

    (30) arith_expr -> NOT . arith_expr
    (17) arith_expr -> . arith_expr PLUS arith_expr
    (18) arith_expr -> . arith_expr MINUS arith_expr
    (19) arith_expr -> . arith_expr STAR arith_expr
    (20) arith_expr -> . arith_expr DIV arith_expr
    (21) arith_expr -> . arith_expr MOD arith_expr
    (22) arith_expr -> . arith_expr AND arith_expr
    (23) arith_expr -> . arith_expr OR arith_expr
    (24) arith_expr -> . arith_expr EQUAL arith_expr
    (25) arith_expr -> . arith_expr NEQUAL arith_expr
    (26) arith_expr -> . arith_expr LTHAN arith_expr
    (27) arith_expr -> . arith_expr LTHANEQ arith_expr
    (28) arith_expr -> . arith_expr GTHAN arith_expr
    (29) arith_expr -> . arith_expr GTHANEQ arith_expr
    (30) arith_expr -> . NOT arith_expr
    (31) arith_expr -> . MINUS arith_expr
    (32) arith_expr -> . LPAREN arith_expr RPAREN
    (33) arith_expr -> . INTCONST
    (34) arith_expr -> . IDENTIFIER

    NOT             shift and go to state 19
    MINUS           shift and go to state 14
    LPAREN          shift and go to state 16
    INTCONST        shift and go to state 17
    IDENTIFIER      shift and go to state 15

    arith_expr                     shift and go to state 41

state 20

    (10) print_stmt -> PRINT LPAREN . arith_expr RPAREN SEMICOLON
    (17) arith_expr -> . arith_expr PLUS arith_expr
    (18) arith_expr -> . arith_expr MINUS arith_expr
    (19) arith_expr -> . arith_expr STAR arith_expr
    (20) arith_expr -> . arith_expr DIV arith_expr
    (21) arith_expr -> . arith_expr MOD arith_expr
    (22) arith_expr -> . arith_expr AND arith_expr
    (23) arith_expr -> . arith_expr OR arith_expr
    (24) arith_expr -> . arith_expr EQUAL arith_expr
    (25) arith_expr -> . arith_expr NEQUAL arith_expr
    (26) arith_expr -> . arith_expr LTHAN arith_expr
    (27) arith_expr -> . arith_expr LTHANEQ arith_expr
    (28) arith_expr -> . arith_expr GTHAN arith_expr
    (29) arith_expr -> . arith_expr GTHANEQ arith_expr
    (30) arith_expr -> . NOT arith_expr
    (31) arith_expr -> . MINUS arith_expr
    (32) arith_expr -> . LPAREN arith_expr RPAREN
    (33) arith_expr -> . INTCONST
    (34) arith_expr -> . IDENTIFIER

    NOT             shift and go to state 19
    MINUS           shift and go to state 14
    LPAREN          shift and go to state 16
    INTCONST        shift and go to state 17
    IDENTIFIER      shift and go to state 15

    arith_expr                     shift and go to state 42

state 21

    (9) assign_stmt -> IDENTIFIER EQUALS . rhs SEMICOLON
    (15) rhs -> . INPUT LPAREN RPAREN
    (16) rhs -> . arith_expr
    (17) arith_expr -> . arith_expr PLUS arith_expr
    (18) arith_expr -> . arith_expr MINUS arith_expr
    (19) arith_expr -> . arith_expr STAR arith_expr
    (20) arith_expr -> . arith_expr DIV arith_expr
    (21) arith_expr -> . arith_expr MOD arith_expr
    (22) arith_expr -> . arith_expr AND arith_expr
    (23) arith_expr -> . arith_expr OR arith_expr
    (24) arith_expr -> . arith_expr EQUAL arith_expr
    (25) arith_expr -> . arith_expr NEQUAL arith_expr
    (26) arith_expr -> . arith_expr LTHAN arith_expr
    (27) arith_expr -> . arith_expr LTHANEQ arith_expr
    (28) arith_expr -> . arith_expr GTHAN arith_expr
    (29) arith_expr -> . arith_expr GTHANEQ arith_expr
    (30) arith_expr -> . NOT arith_expr
    (31) arith_expr -> . MINUS arith_expr
    (32) arith_expr -> . LPAREN arith_expr RPAREN
    (33) arith_expr -> . INTCONST
    (34) arith_expr -> . IDENTIFIER

    INPUT           shift and go to state 44
    NOT             shift and go to state 19
    MINUS           shift and go to state 14
    LPAREN          shift and go to state 16
    INTCONST        shift and go to state 17
    IDENTIFIER      shift and go to state 15

    rhs                            shift and go to state 43
    arith_expr                     shift and go to state 45

state 22

    (2) stmt_seq -> stmt stmt_seq .

    $end            reduce using rule 2 (stmt_seq -> stmt stmt_seq .)
    RBRACE          reduce using rule 2 (stmt_seq -> stmt stmt_seq .)


state 23

    (12) if_stmt -> IF arith_expr . THEN stmt ELSE stmt
    (13) if_stmt -> IF arith_expr . THEN stmt
    (17) arith_expr -> arith_expr . PLUS arith_expr
    (18) arith_expr -> arith_expr . MINUS arith_expr
    (19) arith_expr -> arith_expr . STAR arith_expr
    (20) arith_expr -> arith_expr . DIV arith_expr
    (21) arith_expr -> arith_expr . MOD arith_expr
    (22) arith_expr -> arith_expr . AND arith_expr
    (23) arith_expr -> arith_expr . OR arith_expr
    (24) arith_expr -> arith_expr . EQUAL arith_expr
    (25) arith_expr -> arith_expr . NEQUAL arith_expr
    (26) arith_expr -> arith_expr . LTHAN arith_expr
    (27) arith_expr -> arith_expr . LTHANEQ arith_expr
    (28) arith_expr -> arith_expr . GTHAN arith_expr
    (29) arith_expr -> arith_expr . GTHANEQ arith_expr

    THEN            shift and go to state 46
    PLUS            shift and go to state 35
    MINUS           shift and go to state 39
    STAR            shift and go to state 29
    DIV             shift and go to state 37
    MOD             shift and go to state 40
    AND             shift and go to state 27
    OR              shift and go to state 33
    EQUAL           shift and go to state 32
    NEQUAL          shift and go to state 31
    LTHAN           shift and go to state 34
    LTHANEQ         shift and go to state 36
    GTHAN           shift and go to state 30
    GTHANEQ         shift and go to state 38


state 24

    (11) block_stmt -> LBRACE stmt_seq . RBRACE

    RBRACE          shift and go to state 47


state 25

    (31) arith_expr -> MINUS arith_expr .
    (17) arith_expr -> arith_expr . PLUS arith_expr
    (18) arith_expr -> arith_expr . MINUS arith_expr
    (19) arith_expr -> arith_expr . STAR arith_expr
    (20) arith_expr -> arith_expr . DIV arith_expr
    (21) arith_expr -> arith_expr . MOD arith_expr
    (22) arith_expr -> arith_expr . AND arith_expr
    (23) arith_expr -> arith_expr . OR arith_expr
    (24) arith_expr -> arith_expr . EQUAL arith_expr
    (25) arith_expr -> arith_expr . NEQUAL arith_expr
    (26) arith_expr -> arith_expr . LTHAN arith_expr
    (27) arith_expr -> arith_expr . LTHANEQ arith_expr
    (28) arith_expr -> arith_expr . GTHAN arith_expr
    (29) arith_expr -> arith_expr . GTHANEQ arith_expr

    PLUS            reduce using rule 31 (arith_expr -> MINUS arith_expr .)
    MINUS           reduce using rule 31 (arith_expr -> MINUS arith_expr .)
    STAR            reduce using rule 31 (arith_expr -> MINUS arith_expr .)
    DIV             reduce using rule 31 (arith_expr -> MINUS arith_expr .)
    MOD             reduce using rule 31 (arith_expr -> MINUS arith_expr .)
    AND             reduce using rule 31 (arith_expr -> MINUS arith_expr .)
    OR              reduce using rule 31 (arith_expr -> MINUS arith_expr .)
    EQUAL           reduce using rule 31 (arith_expr -> MINUS arith_expr .)
    NEQUAL          reduce using rule 31 (arith_expr -> MINUS arith_expr .)
    LTHAN           reduce using rule 31 (arith_expr -> MINUS arith_expr .)
    LTHANEQ         reduce using rule 31 (arith_expr -> MINUS arith_expr .)
    GTHAN           reduce using rule 31 (arith_expr -> MINUS arith_expr .)
    GTHANEQ         reduce using rule 31 (arith_expr -> MINUS arith_expr .)
    DO              reduce using rule 31 (arith_expr -> MINUS arith_expr .)
    THEN            reduce using rule 31 (arith_expr -> MINUS arith_expr .)
    RPAREN          reduce using rule 31 (arith_expr -> MINUS arith_expr .)
    SEMICOLON       reduce using rule 31 (arith_expr -> MINUS arith_expr .)

  ! PLUS            [ shift and go to state 35 ]
  ! MINUS           [ shift and go to state 39 ]
  ! STAR            [ shift and go to state 29 ]
  ! DIV             [ shift and go to state 37 ]
  ! MOD             [ shift and go to state 40 ]
  ! AND             [ shift and go to state 27 ]
  ! OR              [ shift and go to state 33 ]
  ! EQUAL           [ shift and go to state 32 ]
  ! NEQUAL          [ shift and go to state 31 ]
  ! LTHAN           [ shift and go to state 34 ]
  ! LTHANEQ         [ shift and go to state 36 ]
  ! GTHAN           [ shift and go to state 30 ]
  ! GTHANEQ         [ shift and go to state 38 ]


state 26

    (32) arith_expr -> LPAREN arith_expr . RPAREN
    (17) arith_expr -> arith_expr . PLUS arith_expr
    (18) arith_expr -> arith_expr . MINUS arith_expr
    (19) arith_expr -> arith_expr . STAR arith_expr
    (20) arith_expr -> arith_expr . DIV arith_expr
    (21) arith_expr -> arith_expr . MOD arith_expr
    (22) arith_expr -> arith_expr . AND arith_expr
    (23) arith_expr -> arith_expr . OR arith_expr
    (24) arith_expr -> arith_expr . EQUAL arith_expr
    (25) arith_expr -> arith_expr . NEQUAL arith_expr
    (26) arith_expr -> arith_expr . LTHAN arith_expr
    (27) arith_expr -> arith_expr . LTHANEQ arith_expr
    (28) arith_expr -> arith_expr . GTHAN arith_expr
    (29) arith_expr -> arith_expr . GTHANEQ arith_expr

    RPAREN          shift and go to state 48
    PLUS            shift and go to state 35
    MINUS           shift and go to state 39
    STAR            shift and go to state 29
    DIV             shift and go to state 37
    MOD             shift and go to state 40
    AND             shift and go to state 27
    OR              shift and go to state 33
    EQUAL           shift and go to state 32
    NEQUAL          shift and go to state 31
    LTHAN           shift and go to state 34
    LTHANEQ         shift and go to state 36
    GTHAN           shift and go to state 30
    GTHANEQ         shift and go to state 38


state 27

    (22) arith_expr -> arith_expr AND . arith_expr
    (17) arith_expr -> . arith_expr PLUS arith_expr
    (18) arith_expr -> . arith_expr MINUS arith_expr
    (19) arith_expr -> . arith_expr STAR arith_expr
    (20) arith_expr -> . arith_expr DIV arith_expr
    (21) arith_expr -> . arith_expr MOD arith_expr
    (22) arith_expr -> . arith_expr AND arith_expr
    (23) arith_expr -> . arith_expr OR arith_expr
    (24) arith_expr -> . arith_expr EQUAL arith_expr
    (25) arith_expr -> . arith_expr NEQUAL arith_expr
    (26) arith_expr -> . arith_expr LTHAN arith_expr
    (27) arith_expr -> . arith_expr LTHANEQ arith_expr
    (28) arith_expr -> . arith_expr GTHAN arith_expr
    (29) arith_expr -> . arith_expr GTHANEQ arith_expr
    (30) arith_expr -> . NOT arith_expr
    (31) arith_expr -> . MINUS arith_expr
    (32) arith_expr -> . LPAREN arith_expr RPAREN
    (33) arith_expr -> . INTCONST
    (34) arith_expr -> . IDENTIFIER

    NOT             shift and go to state 19
    MINUS           shift and go to state 14
    LPAREN          shift and go to state 16
    INTCONST        shift and go to state 17
    IDENTIFIER      shift and go to state 15

    arith_expr                     shift and go to state 49

state 28

    (14) while_stmt -> WHILE arith_expr DO . stmt
    (4) stmt -> . assign_stmt
    (5) stmt -> . print_stmt
    (6) stmt -> . block_stmt
    (7) stmt -> . if_stmt
    (8) stmt -> . while_stmt
    (9) assign_stmt -> . IDENTIFIER EQUALS rhs SEMICOLON
    (10) print_stmt -> . PRINT LPAREN arith_expr RPAREN SEMICOLON
    (11) block_stmt -> . LBRACE stmt_seq RBRACE
    (12) if_stmt -> . IF arith_expr THEN stmt ELSE stmt
    (13) if_stmt -> . IF arith_expr THEN stmt
    (14) while_stmt -> . WHILE arith_expr DO stmt

    IDENTIFIER      shift and go to state 6
    PRINT           shift and go to state 3
    LBRACE          shift and go to state 10
    IF              shift and go to state 9
    WHILE           shift and go to state 2

    if_stmt                        shift and go to state 11
    print_stmt                     shift and go to state 7
    block_stmt                     shift and go to state 4
    assign_stmt                    shift and go to state 5
    while_stmt                     shift and go to state 13
    stmt                           shift and go to state 50

state 29

    (19) arith_expr -> arith_expr STAR . arith_expr
    (17) arith_expr -> . arith_expr PLUS arith_expr
    (18) arith_expr -> . arith_expr MINUS arith_expr
    (19) arith_expr -> . arith_expr STAR arith_expr
    (20) arith_expr -> . arith_expr DIV arith_expr
    (21) arith_expr -> . arith_expr MOD arith_expr
    (22) arith_expr -> . arith_expr AND arith_expr
    (23) arith_expr -> . arith_expr OR arith_expr
    (24) arith_expr -> . arith_expr EQUAL arith_expr
    (25) arith_expr -> . arith_expr NEQUAL arith_expr
    (26) arith_expr -> . arith_expr LTHAN arith_expr
    (27) arith_expr -> . arith_expr LTHANEQ arith_expr
    (28) arith_expr -> . arith_expr GTHAN arith_expr
    (29) arith_expr -> . arith_expr GTHANEQ arith_expr
    (30) arith_expr -> . NOT arith_expr
    (31) arith_expr -> . MINUS arith_expr
    (32) arith_expr -> . LPAREN arith_expr RPAREN
    (33) arith_expr -> . INTCONST
    (34) arith_expr -> . IDENTIFIER

    NOT             shift and go to state 19
    MINUS           shift and go to state 14
    LPAREN          shift and go to state 16
    INTCONST        shift and go to state 17
    IDENTIFIER      shift and go to state 15

    arith_expr                     shift and go to state 51

state 30

    (28) arith_expr -> arith_expr GTHAN . arith_expr
    (17) arith_expr -> . arith_expr PLUS arith_expr
    (18) arith_expr -> . arith_expr MINUS arith_expr
    (19) arith_expr -> . arith_expr STAR arith_expr
    (20) arith_expr -> . arith_expr DIV arith_expr
    (21) arith_expr -> . arith_expr MOD arith_expr
    (22) arith_expr -> . arith_expr AND arith_expr
    (23) arith_expr -> . arith_expr OR arith_expr
    (24) arith_expr -> . arith_expr EQUAL arith_expr
    (25) arith_expr -> . arith_expr NEQUAL arith_expr
    (26) arith_expr -> . arith_expr LTHAN arith_expr
    (27) arith_expr -> . arith_expr LTHANEQ arith_expr
    (28) arith_expr -> . arith_expr GTHAN arith_expr
    (29) arith_expr -> . arith_expr GTHANEQ arith_expr
    (30) arith_expr -> . NOT arith_expr
    (31) arith_expr -> . MINUS arith_expr
    (32) arith_expr -> . LPAREN arith_expr RPAREN
    (33) arith_expr -> . INTCONST
    (34) arith_expr -> . IDENTIFIER

    NOT             shift and go to state 19
    MINUS           shift and go to state 14
    LPAREN          shift and go to state 16
    INTCONST        shift and go to state 17
    IDENTIFIER      shift and go to state 15

    arith_expr                     shift and go to state 52

state 31

    (25) arith_expr -> arith_expr NEQUAL . arith_expr
    (17) arith_expr -> . arith_expr PLUS arith_expr
    (18) arith_expr -> . arith_expr MINUS arith_expr
    (19) arith_expr -> . arith_expr STAR arith_expr
    (20) arith_expr -> . arith_expr DIV arith_expr
    (21) arith_expr -> . arith_expr MOD arith_expr
    (22) arith_expr -> . arith_expr AND arith_expr
    (23) arith_expr -> . arith_expr OR arith_expr
    (24) arith_expr -> . arith_expr EQUAL arith_expr
    (25) arith_expr -> . arith_expr NEQUAL arith_expr
    (26) arith_expr -> . arith_expr LTHAN arith_expr
    (27) arith_expr -> . arith_expr LTHANEQ arith_expr
    (28) arith_expr -> . arith_expr GTHAN arith_expr
    (29) arith_expr -> . arith_expr GTHANEQ arith_expr
    (30) arith_expr -> . NOT arith_expr
    (31) arith_expr -> . MINUS arith_expr
    (32) arith_expr -> . LPAREN arith_expr RPAREN
    (33) arith_expr -> . INTCONST
    (34) arith_expr -> . IDENTIFIER

    NOT             shift and go to state 19
    MINUS           shift and go to state 14
    LPAREN          shift and go to state 16
    INTCONST        shift and go to state 17
    IDENTIFIER      shift and go to state 15

    arith_expr                     shift and go to state 53

state 32

    (24) arith_expr -> arith_expr EQUAL . arith_expr
    (17) arith_expr -> . arith_expr PLUS arith_expr
    (18) arith_expr -> . arith_expr MINUS arith_expr
    (19) arith_expr -> . arith_expr STAR arith_expr
    (20) arith_expr -> . arith_expr DIV arith_expr
    (21) arith_expr -> . arith_expr MOD arith_expr
    (22) arith_expr -> . arith_expr AND arith_expr
    (23) arith_expr -> . arith_expr OR arith_expr
    (24) arith_expr -> . arith_expr EQUAL arith_expr
    (25) arith_expr -> . arith_expr NEQUAL arith_expr
    (26) arith_expr -> . arith_expr LTHAN arith_expr
    (27) arith_expr -> . arith_expr LTHANEQ arith_expr
    (28) arith_expr -> . arith_expr GTHAN arith_expr
    (29) arith_expr -> . arith_expr GTHANEQ arith_expr
    (30) arith_expr -> . NOT arith_expr
    (31) arith_expr -> . MINUS arith_expr
    (32) arith_expr -> . LPAREN arith_expr RPAREN
    (33) arith_expr -> . INTCONST
    (34) arith_expr -> . IDENTIFIER

    NOT             shift and go to state 19
    MINUS           shift and go to state 14
    LPAREN          shift and go to state 16
    INTCONST        shift and go to state 17
    IDENTIFIER      shift and go to state 15

    arith_expr                     shift and go to state 54

state 33

    (23) arith_expr -> arith_expr OR . arith_expr
    (17) arith_expr -> . arith_expr PLUS arith_expr
    (18) arith_expr -> . arith_expr MINUS arith_expr
    (19) arith_expr -> . arith_expr STAR arith_expr
    (20) arith_expr -> . arith_expr DIV arith_expr
    (21) arith_expr -> . arith_expr MOD arith_expr
    (22) arith_expr -> . arith_expr AND arith_expr
    (23) arith_expr -> . arith_expr OR arith_expr
    (24) arith_expr -> . arith_expr EQUAL arith_expr
    (25) arith_expr -> . arith_expr NEQUAL arith_expr
    (26) arith_expr -> . arith_expr LTHAN arith_expr
    (27) arith_expr -> . arith_expr LTHANEQ arith_expr
    (28) arith_expr -> . arith_expr GTHAN arith_expr
    (29) arith_expr -> . arith_expr GTHANEQ arith_expr
    (30) arith_expr -> . NOT arith_expr
    (31) arith_expr -> . MINUS arith_expr
    (32) arith_expr -> . LPAREN arith_expr RPAREN
    (33) arith_expr -> . INTCONST
    (34) arith_expr -> . IDENTIFIER

    NOT             shift and go to state 19
    MINUS           shift and go to state 14
    LPAREN          shift and go to state 16
    INTCONST        shift and go to state 17
    IDENTIFIER      shift and go to state 15

    arith_expr                     shift and go to state 55

state 34

    (26) arith_expr -> arith_expr LTHAN . arith_expr
    (17) arith_expr -> . arith_expr PLUS arith_expr
    (18) arith_expr -> . arith_expr MINUS arith_expr
    (19) arith_expr -> . arith_expr STAR arith_expr
    (20) arith_expr -> . arith_expr DIV arith_expr
    (21) arith_expr -> . arith_expr MOD arith_expr
    (22) arith_expr -> . arith_expr AND arith_expr
    (23) arith_expr -> . arith_expr OR arith_expr
    (24) arith_expr -> . arith_expr EQUAL arith_expr
    (25) arith_expr -> . arith_expr NEQUAL arith_expr
    (26) arith_expr -> . arith_expr LTHAN arith_expr
    (27) arith_expr -> . arith_expr LTHANEQ arith_expr
    (28) arith_expr -> . arith_expr GTHAN arith_expr
    (29) arith_expr -> . arith_expr GTHANEQ arith_expr
    (30) arith_expr -> . NOT arith_expr
    (31) arith_expr -> . MINUS arith_expr
    (32) arith_expr -> . LPAREN arith_expr RPAREN
    (33) arith_expr -> . INTCONST
    (34) arith_expr -> . IDENTIFIER

    NOT             shift and go to state 19
    MINUS           shift and go to state 14
    LPAREN          shift and go to state 16
    INTCONST        shift and go to state 17
    IDENTIFIER      shift and go to state 15

    arith_expr                     shift and go to state 56

state 35

    (17) arith_expr -> arith_expr PLUS . arith_expr
    (17) arith_expr -> . arith_expr PLUS arith_expr
    (18) arith_expr -> . arith_expr MINUS arith_expr
    (19) arith_expr -> . arith_expr STAR arith_expr
    (20) arith_expr -> . arith_expr DIV arith_expr
    (21) arith_expr -> . arith_expr MOD arith_expr
    (22) arith_expr -> . arith_expr AND arith_expr
    (23) arith_expr -> . arith_expr OR arith_expr
    (24) arith_expr -> . arith_expr EQUAL arith_expr
    (25) arith_expr -> . arith_expr NEQUAL arith_expr
    (26) arith_expr -> . arith_expr LTHAN arith_expr
    (27) arith_expr -> . arith_expr LTHANEQ arith_expr
    (28) arith_expr -> . arith_expr GTHAN arith_expr
    (29) arith_expr -> . arith_expr GTHANEQ arith_expr
    (30) arith_expr -> . NOT arith_expr
    (31) arith_expr -> . MINUS arith_expr
    (32) arith_expr -> . LPAREN arith_expr RPAREN
    (33) arith_expr -> . INTCONST
    (34) arith_expr -> . IDENTIFIER

    NOT             shift and go to state 19
    MINUS           shift and go to state 14
    LPAREN          shift and go to state 16
    INTCONST        shift and go to state 17
    IDENTIFIER      shift and go to state 15

    arith_expr                     shift and go to state 57

state 36

    (27) arith_expr -> arith_expr LTHANEQ . arith_expr
    (17) arith_expr -> . arith_expr PLUS arith_expr
    (18) arith_expr -> . arith_expr MINUS arith_expr
    (19) arith_expr -> . arith_expr STAR arith_expr
    (20) arith_expr -> . arith_expr DIV arith_expr
    (21) arith_expr -> . arith_expr MOD arith_expr
    (22) arith_expr -> . arith_expr AND arith_expr
    (23) arith_expr -> . arith_expr OR arith_expr
    (24) arith_expr -> . arith_expr EQUAL arith_expr
    (25) arith_expr -> . arith_expr NEQUAL arith_expr
    (26) arith_expr -> . arith_expr LTHAN arith_expr
    (27) arith_expr -> . arith_expr LTHANEQ arith_expr
    (28) arith_expr -> . arith_expr GTHAN arith_expr
    (29) arith_expr -> . arith_expr GTHANEQ arith_expr
    (30) arith_expr -> . NOT arith_expr
    (31) arith_expr -> . MINUS arith_expr
    (32) arith_expr -> . LPAREN arith_expr RPAREN
    (33) arith_expr -> . INTCONST
    (34) arith_expr -> . IDENTIFIER

    NOT             shift and go to state 19
    MINUS           shift and go to state 14
    LPAREN          shift and go to state 16
    INTCONST        shift and go to state 17
    IDENTIFIER      shift and go to state 15

    arith_expr                     shift and go to state 58

state 37

    (20) arith_expr -> arith_expr DIV . arith_expr
    (17) arith_expr -> . arith_expr PLUS arith_expr
    (18) arith_expr -> . arith_expr MINUS arith_expr
    (19) arith_expr -> . arith_expr STAR arith_expr
    (20) arith_expr -> . arith_expr DIV arith_expr
    (21) arith_expr -> . arith_expr MOD arith_expr
    (22) arith_expr -> . arith_expr AND arith_expr
    (23) arith_expr -> . arith_expr OR arith_expr
    (24) arith_expr -> . arith_expr EQUAL arith_expr
    (25) arith_expr -> . arith_expr NEQUAL arith_expr
    (26) arith_expr -> . arith_expr LTHAN arith_expr
    (27) arith_expr -> . arith_expr LTHANEQ arith_expr
    (28) arith_expr -> . arith_expr GTHAN arith_expr
    (29) arith_expr -> . arith_expr GTHANEQ arith_expr
    (30) arith_expr -> . NOT arith_expr
    (31) arith_expr -> . MINUS arith_expr
    (32) arith_expr -> . LPAREN arith_expr RPAREN
    (33) arith_expr -> . INTCONST
    (34) arith_expr -> . IDENTIFIER

    NOT             shift and go to state 19
    MINUS           shift and go to state 14
    LPAREN          shift and go to state 16
    INTCONST        shift and go to state 17
    IDENTIFIER      shift and go to state 15

    arith_expr                     shift and go to state 59

state 38

    (29) arith_expr -> arith_expr GTHANEQ . arith_expr
    (17) arith_expr -> . arith_expr PLUS arith_expr
    (18) arith_expr -> . arith_expr MINUS arith_expr
    (19) arith_expr -> . arith_expr STAR arith_expr
    (20) arith_expr -> . arith_expr DIV arith_expr
    (21) arith_expr -> . arith_expr MOD arith_expr
    (22) arith_expr -> . arith_expr AND arith_expr
    (23) arith_expr -> . arith_expr OR arith_expr
    (24) arith_expr -> . arith_expr EQUAL arith_expr
    (25) arith_expr -> . arith_expr NEQUAL arith_expr
    (26) arith_expr -> . arith_expr LTHAN arith_expr
    (27) arith_expr -> . arith_expr LTHANEQ arith_expr
    (28) arith_expr -> . arith_expr GTHAN arith_expr
    (29) arith_expr -> . arith_expr GTHANEQ arith_expr
    (30) arith_expr -> . NOT arith_expr
    (31) arith_expr -> . MINUS arith_expr
    (32) arith_expr -> . LPAREN arith_expr RPAREN
    (33) arith_expr -> . INTCONST
    (34) arith_expr -> . IDENTIFIER

    NOT             shift and go to state 19
    MINUS           shift and go to state 14
    LPAREN          shift and go to state 16
    INTCONST        shift and go to state 17
    IDENTIFIER      shift and go to state 15

    arith_expr                     shift and go to state 60

state 39

    (18) arith_expr -> arith_expr MINUS . arith_expr
    (17) arith_expr -> . arith_expr PLUS arith_expr
    (18) arith_expr -> . arith_expr MINUS arith_expr
    (19) arith_expr -> . arith_expr STAR arith_expr
    (20) arith_expr -> . arith_expr DIV arith_expr
    (21) arith_expr -> . arith_expr MOD arith_expr
    (22) arith_expr -> . arith_expr AND arith_expr
    (23) arith_expr -> . arith_expr OR arith_expr
    (24) arith_expr -> . arith_expr EQUAL arith_expr
    (25) arith_expr -> . arith_expr NEQUAL arith_expr
    (26) arith_expr -> . arith_expr LTHAN arith_expr
    (27) arith_expr -> . arith_expr LTHANEQ arith_expr
    (28) arith_expr -> . arith_expr GTHAN arith_expr
    (29) arith_expr -> . arith_expr GTHANEQ arith_expr
    (30) arith_expr -> . NOT arith_expr
    (31) arith_expr -> . MINUS arith_expr
    (32) arith_expr -> . LPAREN arith_expr RPAREN
    (33) arith_expr -> . INTCONST
    (34) arith_expr -> . IDENTIFIER

    NOT             shift and go to state 19
    MINUS           shift and go to state 14
    LPAREN          shift and go to state 16
    INTCONST        shift and go to state 17
    IDENTIFIER      shift and go to state 15

    arith_expr                     shift and go to state 61

state 40

    (21) arith_expr -> arith_expr MOD . arith_expr
    (17) arith_expr -> . arith_expr PLUS arith_expr
    (18) arith_expr -> . arith_expr MINUS arith_expr
    (19) arith_expr -> . arith_expr STAR arith_expr
    (20) arith_expr -> . arith_expr DIV arith_expr
    (21) arith_expr -> . arith_expr MOD arith_expr
    (22) arith_expr -> . arith_expr AND arith_expr
    (23) arith_expr -> . arith_expr OR arith_expr
    (24) arith_expr -> . arith_expr EQUAL arith_expr
    (25) arith_expr -> . arith_expr NEQUAL arith_expr
    (26) arith_expr -> . arith_expr LTHAN arith_expr
    (27) arith_expr -> . arith_expr LTHANEQ arith_expr
    (28) arith_expr -> . arith_expr GTHAN arith_expr
    (29) arith_expr -> . arith_expr GTHANEQ arith_expr
    (30) arith_expr -> . NOT arith_expr
    (31) arith_expr -> . MINUS arith_expr
    (32) arith_expr -> . LPAREN arith_expr RPAREN
    (33) arith_expr -> . INTCONST
    (34) arith_expr -> . IDENTIFIER

    NOT             shift and go to state 19
    MINUS           shift and go to state 14
    LPAREN          shift and go to state 16
    INTCONST        shift and go to state 17
    IDENTIFIER      shift and go to state 15

    arith_expr                     shift and go to state 62

state 41

    (30) arith_expr -> NOT arith_expr .
    (17) arith_expr -> arith_expr . PLUS arith_expr
    (18) arith_expr -> arith_expr . MINUS arith_expr
    (19) arith_expr -> arith_expr . STAR arith_expr
    (20) arith_expr -> arith_expr . DIV arith_expr
    (21) arith_expr -> arith_expr . MOD arith_expr
    (22) arith_expr -> arith_expr . AND arith_expr
    (23) arith_expr -> arith_expr . OR arith_expr
    (24) arith_expr -> arith_expr . EQUAL arith_expr
    (25) arith_expr -> arith_expr . NEQUAL arith_expr
    (26) arith_expr -> arith_expr . LTHAN arith_expr
    (27) arith_expr -> arith_expr . LTHANEQ arith_expr
    (28) arith_expr -> arith_expr . GTHAN arith_expr
    (29) arith_expr -> arith_expr . GTHANEQ arith_expr

    PLUS            reduce using rule 30 (arith_expr -> NOT arith_expr .)
    MINUS           reduce using rule 30 (arith_expr -> NOT arith_expr .)
    STAR            reduce using rule 30 (arith_expr -> NOT arith_expr .)
    DIV             reduce using rule 30 (arith_expr -> NOT arith_expr .)
    MOD             reduce using rule 30 (arith_expr -> NOT arith_expr .)
    AND             reduce using rule 30 (arith_expr -> NOT arith_expr .)
    OR              reduce using rule 30 (arith_expr -> NOT arith_expr .)
    EQUAL           reduce using rule 30 (arith_expr -> NOT arith_expr .)
    NEQUAL          reduce using rule 30 (arith_expr -> NOT arith_expr .)
    LTHAN           reduce using rule 30 (arith_expr -> NOT arith_expr .)
    LTHANEQ         reduce using rule 30 (arith_expr -> NOT arith_expr .)
    GTHAN           reduce using rule 30 (arith_expr -> NOT arith_expr .)
    GTHANEQ         reduce using rule 30 (arith_expr -> NOT arith_expr .)
    DO              reduce using rule 30 (arith_expr -> NOT arith_expr .)
    THEN            reduce using rule 30 (arith_expr -> NOT arith_expr .)
    RPAREN          reduce using rule 30 (arith_expr -> NOT arith_expr .)
    SEMICOLON       reduce using rule 30 (arith_expr -> NOT arith_expr .)

  ! PLUS            [ shift and go to state 35 ]
  ! MINUS           [ shift and go to state 39 ]
  ! STAR            [ shift and go to state 29 ]
  ! DIV             [ shift and go to state 37 ]
  ! MOD             [ shift and go to state 40 ]
  ! AND             [ shift and go to state 27 ]
  ! OR              [ shift and go to state 33 ]
  ! EQUAL           [ shift and go to state 32 ]
  ! NEQUAL          [ shift and go to state 31 ]
  ! LTHAN           [ shift and go to state 34 ]
  ! LTHANEQ         [ shift and go to state 36 ]
  ! GTHAN           [ shift and go to state 30 ]
  ! GTHANEQ         [ shift and go to state 38 ]


state 42

    (10) print_stmt -> PRINT LPAREN arith_expr . RPAREN SEMICOLON
    (17) arith_expr -> arith_expr . PLUS arith_expr
    (18) arith_expr -> arith_expr . MINUS arith_expr
    (19) arith_expr -> arith_expr . STAR arith_expr
    (20) arith_expr -> arith_expr . DIV arith_expr
    (21) arith_expr -> arith_expr . MOD arith_expr
    (22) arith_expr -> arith_expr . AND arith_expr
    (23) arith_expr -> arith_expr . OR arith_expr
    (24) arith_expr -> arith_expr . EQUAL arith_expr
    (25) arith_expr -> arith_expr . NEQUAL arith_expr
    (26) arith_expr -> arith_expr . LTHAN arith_expr
    (27) arith_expr -> arith_expr . LTHANEQ arith_expr
    (28) arith_expr -> arith_expr . GTHAN arith_expr
    (29) arith_expr -> arith_expr . GTHANEQ arith_expr

    RPAREN          shift and go to state 63
    PLUS            shift and go to state 35
    MINUS           shift and go to state 39
    STAR            shift and go to state 29
    DIV             shift and go to state 37
    MOD             shift and go to state 40
    AND             shift and go to state 27
    OR              shift and go to state 33
    EQUAL           shift and go to state 32
    NEQUAL          shift and go to state 31
    LTHAN           shift and go to state 34
    LTHANEQ         shift and go to state 36
    GTHAN           shift and go to state 30
    GTHANEQ         shift and go to state 38


state 43

    (9) assign_stmt -> IDENTIFIER EQUALS rhs . SEMICOLON

    SEMICOLON       shift and go to state 64


state 44

    (15) rhs -> INPUT . LPAREN RPAREN

    LPAREN          shift and go to state 65


state 45

    (16) rhs -> arith_expr .
    (17) arith_expr -> arith_expr . PLUS arith_expr
    (18) arith_expr -> arith_expr . MINUS arith_expr
    (19) arith_expr -> arith_expr . STAR arith_expr
    (20) arith_expr -> arith_expr . DIV arith_expr
    (21) arith_expr -> arith_expr . MOD arith_expr
    (22) arith_expr -> arith_expr . AND arith_expr
    (23) arith_expr -> arith_expr . OR arith_expr
    (24) arith_expr -> arith_expr . EQUAL arith_expr
    (25) arith_expr -> arith_expr . NEQUAL arith_expr
    (26) arith_expr -> arith_expr . LTHAN arith_expr
    (27) arith_expr -> arith_expr . LTHANEQ arith_expr
    (28) arith_expr -> arith_expr . GTHAN arith_expr
    (29) arith_expr -> arith_expr . GTHANEQ arith_expr

    SEMICOLON       reduce using rule 16 (rhs -> arith_expr .)
    PLUS            shift and go to state 35
    MINUS           shift and go to state 39
    STAR            shift and go to state 29
    DIV             shift and go to state 37
    MOD             shift and go to state 40
    AND             shift and go to state 27
    OR              shift and go to state 33
    EQUAL           shift and go to state 32
    NEQUAL          shift and go to state 31
    LTHAN           shift and go to state 34
    LTHANEQ         shift and go to state 36
    GTHAN           shift and go to state 30
    GTHANEQ         shift and go to state 38


state 46

    (12) if_stmt -> IF arith_expr THEN . stmt ELSE stmt
    (13) if_stmt -> IF arith_expr THEN . stmt
    (4) stmt -> . assign_stmt
    (5) stmt -> . print_stmt
    (6) stmt -> . block_stmt
    (7) stmt -> . if_stmt
    (8) stmt -> . while_stmt
    (9) assign_stmt -> . IDENTIFIER EQUALS rhs SEMICOLON
    (10) print_stmt -> . PRINT LPAREN arith_expr RPAREN SEMICOLON
    (11) block_stmt -> . LBRACE stmt_seq RBRACE
    (12) if_stmt -> . IF arith_expr THEN stmt ELSE stmt
    (13) if_stmt -> . IF arith_expr THEN stmt
    (14) while_stmt -> . WHILE arith_expr DO stmt

    IDENTIFIER      shift and go to state 6
    PRINT           shift and go to state 3
    LBRACE          shift and go to state 10
    IF              shift and go to state 9
    WHILE           shift and go to state 2

    if_stmt                        shift and go to state 11
    print_stmt                     shift and go to state 7
    block_stmt                     shift and go to state 4
    assign_stmt                    shift and go to state 5
    while_stmt                     shift and go to state 13
    stmt                           shift and go to state 66

state 47

    (11) block_stmt -> LBRACE stmt_seq RBRACE .

    IDENTIFIER      reduce using rule 11 (block_stmt -> LBRACE stmt_seq RBRACE .)
    PRINT           reduce using rule 11 (block_stmt -> LBRACE stmt_seq RBRACE .)
    LBRACE          reduce using rule 11 (block_stmt -> LBRACE stmt_seq RBRACE .)
    IF              reduce using rule 11 (block_stmt -> LBRACE stmt_seq RBRACE .)
    WHILE           reduce using rule 11 (block_stmt -> LBRACE stmt_seq RBRACE .)
    $end            reduce using rule 11 (block_stmt -> LBRACE stmt_seq RBRACE .)
    RBRACE          reduce using rule 11 (block_stmt -> LBRACE stmt_seq RBRACE .)
    ELSE            reduce using rule 11 (block_stmt -> LBRACE stmt_seq RBRACE .)


state 48

    (32) arith_expr -> LPAREN arith_expr RPAREN .

    PLUS            reduce using rule 32 (arith_expr -> LPAREN arith_expr RPAREN .)
    MINUS           reduce using rule 32 (arith_expr -> LPAREN arith_expr RPAREN .)
    STAR            reduce using rule 32 (arith_expr -> LPAREN arith_expr RPAREN .)
    DIV             reduce using rule 32 (arith_expr -> LPAREN arith_expr RPAREN .)
    MOD             reduce using rule 32 (arith_expr -> LPAREN arith_expr RPAREN .)
    AND             reduce using rule 32 (arith_expr -> LPAREN arith_expr RPAREN .)
    OR              reduce using rule 32 (arith_expr -> LPAREN arith_expr RPAREN .)
    EQUAL           reduce using rule 32 (arith_expr -> LPAREN arith_expr RPAREN .)
    NEQUAL          reduce using rule 32 (arith_expr -> LPAREN arith_expr RPAREN .)
    LTHAN           reduce using rule 32 (arith_expr -> LPAREN arith_expr RPAREN .)
    LTHANEQ         reduce using rule 32 (arith_expr -> LPAREN arith_expr RPAREN .)
    GTHAN           reduce using rule 32 (arith_expr -> LPAREN arith_expr RPAREN .)
    GTHANEQ         reduce using rule 32 (arith_expr -> LPAREN arith_expr RPAREN .)
    DO              reduce using rule 32 (arith_expr -> LPAREN arith_expr RPAREN .)
    THEN            reduce using rule 32 (arith_expr -> LPAREN arith_expr RPAREN .)
    RPAREN          reduce using rule 32 (arith_expr -> LPAREN arith_expr RPAREN .)
    SEMICOLON       reduce using rule 32 (arith_expr -> LPAREN arith_expr RPAREN .)


state 49

    (22) arith_expr -> arith_expr AND arith_expr .
    (17) arith_expr -> arith_expr . PLUS arith_expr
    (18) arith_expr -> arith_expr . MINUS arith_expr
    (19) arith_expr -> arith_expr . STAR arith_expr
    (20) arith_expr -> arith_expr . DIV arith_expr
    (21) arith_expr -> arith_expr . MOD arith_expr
    (22) arith_expr -> arith_expr . AND arith_expr
    (23) arith_expr -> arith_expr . OR arith_expr
    (24) arith_expr -> arith_expr . EQUAL arith_expr
    (25) arith_expr -> arith_expr . NEQUAL arith_expr
    (26) arith_expr -> arith_expr . LTHAN arith_expr
    (27) arith_expr -> arith_expr . LTHANEQ arith_expr
    (28) arith_expr -> arith_expr . GTHAN arith_expr
    (29) arith_expr -> arith_expr . GTHANEQ arith_expr

    AND             reduce using rule 22 (arith_expr -> arith_expr AND arith_expr .)
    OR              reduce using rule 22 (arith_expr -> arith_expr AND arith_expr .)
    DO              reduce using rule 22 (arith_expr -> arith_expr AND arith_expr .)
    THEN            reduce using rule 22 (arith_expr -> arith_expr AND arith_expr .)
    RPAREN          reduce using rule 22 (arith_expr -> arith_expr AND arith_expr .)
    SEMICOLON       reduce using rule 22 (arith_expr -> arith_expr AND arith_expr .)
    PLUS            shift and go to state 35
    MINUS           shift and go to state 39
    STAR            shift and go to state 29
    DIV             shift and go to state 37
    MOD             shift and go to state 40
    EQUAL           shift and go to state 32
    NEQUAL          shift and go to state 31
    LTHAN           shift and go to state 34
    LTHANEQ         shift and go to state 36
    GTHAN           shift and go to state 30
    GTHANEQ         shift and go to state 38

  ! PLUS            [ reduce using rule 22 (arith_expr -> arith_expr AND arith_expr .) ]
  ! MINUS           [ reduce using rule 22 (arith_expr -> arith_expr AND arith_expr .) ]
  ! STAR            [ reduce using rule 22 (arith_expr -> arith_expr AND arith_expr .) ]
  ! DIV             [ reduce using rule 22 (arith_expr -> arith_expr AND arith_expr .) ]
  ! MOD             [ reduce using rule 22 (arith_expr -> arith_expr AND arith_expr .) ]
  ! EQUAL           [ reduce using rule 22 (arith_expr -> arith_expr AND arith_expr .) ]
  ! NEQUAL          [ reduce using rule 22 (arith_expr -> arith_expr AND arith_expr .) ]
  ! LTHAN           [ reduce using rule 22 (arith_expr -> arith_expr AND arith_expr .) ]
  ! LTHANEQ         [ reduce using rule 22 (arith_expr -> arith_expr AND arith_expr .) ]
  ! GTHAN           [ reduce using rule 22 (arith_expr -> arith_expr AND arith_expr .) ]
  ! GTHANEQ         [ reduce using rule 22 (arith_expr -> arith_expr AND arith_expr .) ]
  ! AND             [ shift and go to state 27 ]
  ! OR              [ shift and go to state 33 ]


state 50

    (14) while_stmt -> WHILE arith_expr DO stmt .

    IDENTIFIER      reduce using rule 14 (while_stmt -> WHILE arith_expr DO stmt .)
    PRINT           reduce using rule 14 (while_stmt -> WHILE arith_expr DO stmt .)
    LBRACE          reduce using rule 14 (while_stmt -> WHILE arith_expr DO stmt .)
    IF              reduce using rule 14 (while_stmt -> WHILE arith_expr DO stmt .)
    WHILE           reduce using rule 14 (while_stmt -> WHILE arith_expr DO stmt .)
    $end            reduce using rule 14 (while_stmt -> WHILE arith_expr DO stmt .)
    RBRACE          reduce using rule 14 (while_stmt -> WHILE arith_expr DO stmt .)
    ELSE            reduce using rule 14 (while_stmt -> WHILE arith_expr DO stmt .)


state 51

    (19) arith_expr -> arith_expr STAR arith_expr .
    (17) arith_expr -> arith_expr . PLUS arith_expr
    (18) arith_expr -> arith_expr . MINUS arith_expr
    (19) arith_expr -> arith_expr . STAR arith_expr
    (20) arith_expr -> arith_expr . DIV arith_expr
    (21) arith_expr -> arith_expr . MOD arith_expr
    (22) arith_expr -> arith_expr . AND arith_expr
    (23) arith_expr -> arith_expr . OR arith_expr
    (24) arith_expr -> arith_expr . EQUAL arith_expr
    (25) arith_expr -> arith_expr . NEQUAL arith_expr
    (26) arith_expr -> arith_expr . LTHAN arith_expr
    (27) arith_expr -> arith_expr . LTHANEQ arith_expr
    (28) arith_expr -> arith_expr . GTHAN arith_expr
    (29) arith_expr -> arith_expr . GTHANEQ arith_expr

    PLUS            reduce using rule 19 (arith_expr -> arith_expr STAR arith_expr .)
    MINUS           reduce using rule 19 (arith_expr -> arith_expr STAR arith_expr .)
    STAR            reduce using rule 19 (arith_expr -> arith_expr STAR arith_expr .)
    DIV             reduce using rule 19 (arith_expr -> arith_expr STAR arith_expr .)
    MOD             reduce using rule 19 (arith_expr -> arith_expr STAR arith_expr .)
    AND             reduce using rule 19 (arith_expr -> arith_expr STAR arith_expr .)
    OR              reduce using rule 19 (arith_expr -> arith_expr STAR arith_expr .)
    EQUAL           reduce using rule 19 (arith_expr -> arith_expr STAR arith_expr .)
    NEQUAL          reduce using rule 19 (arith_expr -> arith_expr STAR arith_expr .)
    LTHAN           reduce using rule 19 (arith_expr -> arith_expr STAR arith_expr .)
    LTHANEQ         reduce using rule 19 (arith_expr -> arith_expr STAR arith_expr .)
    GTHAN           reduce using rule 19 (arith_expr -> arith_expr STAR arith_expr .)
    GTHANEQ         reduce using rule 19 (arith_expr -> arith_expr STAR arith_expr .)
    DO              reduce using rule 19 (arith_expr -> arith_expr STAR arith_expr .)
    THEN            reduce using rule 19 (arith_expr -> arith_expr STAR arith_expr .)
    RPAREN          reduce using rule 19 (arith_expr -> arith_expr STAR arith_expr .)
    SEMICOLON       reduce using rule 19 (arith_expr -> arith_expr STAR arith_expr .)

  ! PLUS            [ shift and go to state 35 ]
  ! MINUS           [ shift and go to state 39 ]
  ! STAR            [ shift and go to state 29 ]
  ! DIV             [ shift and go to state 37 ]
  ! MOD             [ shift and go to state 40 ]
  ! AND             [ shift and go to state 27 ]
  ! OR              [ shift and go to state 33 ]
  ! EQUAL           [ shift and go to state 32 ]
  ! NEQUAL          [ shift and go to state 31 ]
  ! LTHAN           [ shift and go to state 34 ]
  ! LTHANEQ         [ shift and go to state 36 ]
  ! GTHAN           [ shift and go to state 30 ]
  ! GTHANEQ         [ shift and go to state 38 ]


state 52

    (28) arith_expr -> arith_expr GTHAN arith_expr .
    (17) arith_expr -> arith_expr . PLUS arith_expr
    (18) arith_expr -> arith_expr . MINUS arith_expr
    (19) arith_expr -> arith_expr . STAR arith_expr
    (20) arith_expr -> arith_expr . DIV arith_expr
    (21) arith_expr -> arith_expr . MOD arith_expr
    (22) arith_expr -> arith_expr . AND arith_expr
    (23) arith_expr -> arith_expr . OR arith_expr
    (24) arith_expr -> arith_expr . EQUAL arith_expr
    (25) arith_expr -> arith_expr . NEQUAL arith_expr
    (26) arith_expr -> arith_expr . LTHAN arith_expr
    (27) arith_expr -> arith_expr . LTHANEQ arith_expr
    (28) arith_expr -> arith_expr . GTHAN arith_expr
    (29) arith_expr -> arith_expr . GTHANEQ arith_expr

    AND             reduce using rule 28 (arith_expr -> arith_expr GTHAN arith_expr .)
    OR              reduce using rule 28 (arith_expr -> arith_expr GTHAN arith_expr .)
    EQUAL           reduce using rule 28 (arith_expr -> arith_expr GTHAN arith_expr .)
    NEQUAL          reduce using rule 28 (arith_expr -> arith_expr GTHAN arith_expr .)
    LTHAN           reduce using rule 28 (arith_expr -> arith_expr GTHAN arith_expr .)
    LTHANEQ         reduce using rule 28 (arith_expr -> arith_expr GTHAN arith_expr .)
    GTHAN           reduce using rule 28 (arith_expr -> arith_expr GTHAN arith_expr .)
    GTHANEQ         reduce using rule 28 (arith_expr -> arith_expr GTHAN arith_expr .)
    DO              reduce using rule 28 (arith_expr -> arith_expr GTHAN arith_expr .)
    THEN            reduce using rule 28 (arith_expr -> arith_expr GTHAN arith_expr .)
    RPAREN          reduce using rule 28 (arith_expr -> arith_expr GTHAN arith_expr .)
    SEMICOLON       reduce using rule 28 (arith_expr -> arith_expr GTHAN arith_expr .)
    PLUS            shift and go to state 35
    MINUS           shift and go to state 39
    STAR            shift and go to state 29
    DIV             shift and go to state 37
    MOD             shift and go to state 40

  ! PLUS            [ reduce using rule 28 (arith_expr -> arith_expr GTHAN arith_expr .) ]
  ! MINUS           [ reduce using rule 28 (arith_expr -> arith_expr GTHAN arith_expr .) ]
  ! STAR            [ reduce using rule 28 (arith_expr -> arith_expr GTHAN arith_expr .) ]
  ! DIV             [ reduce using rule 28 (arith_expr -> arith_expr GTHAN arith_expr .) ]
  ! MOD             [ reduce using rule 28 (arith_expr -> arith_expr GTHAN arith_expr .) ]
  ! AND             [ shift and go to state 27 ]
  ! OR              [ shift and go to state 33 ]
  ! EQUAL           [ shift and go to state 32 ]
  ! NEQUAL          [ shift and go to state 31 ]
  ! LTHAN           [ shift and go to state 34 ]
  ! LTHANEQ         [ shift and go to state 36 ]
  ! GTHAN           [ shift and go to state 30 ]
  ! GTHANEQ         [ shift and go to state 38 ]


state 53

    (25) arith_expr -> arith_expr NEQUAL arith_expr .
    (17) arith_expr -> arith_expr . PLUS arith_expr
    (18) arith_expr -> arith_expr . MINUS arith_expr
    (19) arith_expr -> arith_expr . STAR arith_expr
    (20) arith_expr -> arith_expr . DIV arith_expr
    (21) arith_expr -> arith_expr . MOD arith_expr
    (22) arith_expr -> arith_expr . AND arith_expr
    (23) arith_expr -> arith_expr . OR arith_expr
    (24) arith_expr -> arith_expr . EQUAL arith_expr
    (25) arith_expr -> arith_expr . NEQUAL arith_expr
    (26) arith_expr -> arith_expr . LTHAN arith_expr
    (27) arith_expr -> arith_expr . LTHANEQ arith_expr
    (28) arith_expr -> arith_expr . GTHAN arith_expr
    (29) arith_expr -> arith_expr . GTHANEQ arith_expr

    AND             reduce using rule 25 (arith_expr -> arith_expr NEQUAL arith_expr .)
    OR              reduce using rule 25 (arith_expr -> arith_expr NEQUAL arith_expr .)
    EQUAL           reduce using rule 25 (arith_expr -> arith_expr NEQUAL arith_expr .)
    NEQUAL          reduce using rule 25 (arith_expr -> arith_expr NEQUAL arith_expr .)
    LTHAN           reduce using rule 25 (arith_expr -> arith_expr NEQUAL arith_expr .)
    LTHANEQ         reduce using rule 25 (arith_expr -> arith_expr NEQUAL arith_expr .)
    GTHAN           reduce using rule 25 (arith_expr -> arith_expr NEQUAL arith_expr .)
    GTHANEQ         reduce using rule 25 (arith_expr -> arith_expr NEQUAL arith_expr .)
    DO              reduce using rule 25 (arith_expr -> arith_expr NEQUAL arith_expr .)
    THEN            reduce using rule 25 (arith_expr -> arith_expr NEQUAL arith_expr .)
    RPAREN          reduce using rule 25 (arith_expr -> arith_expr NEQUAL arith_expr .)
    SEMICOLON       reduce using rule 25 (arith_expr -> arith_expr NEQUAL arith_expr .)
    PLUS            shift and go to state 35
    MINUS           shift and go to state 39
    STAR            shift and go to state 29
    DIV             shift and go to state 37
    MOD             shift and go to state 40

  ! PLUS            [ reduce using rule 25 (arith_expr -> arith_expr NEQUAL arith_expr .) ]
  ! MINUS           [ reduce using rule 25 (arith_expr -> arith_expr NEQUAL arith_expr .) ]
  ! STAR            [ reduce using rule 25 (arith_expr -> arith_expr NEQUAL arith_expr .) ]
  ! DIV             [ reduce using rule 25 (arith_expr -> arith_expr NEQUAL arith_expr .) ]
  ! MOD             [ reduce using rule 25 (arith_expr -> arith_expr NEQUAL arith_expr .) ]
  ! AND             [ shift and go to state 27 ]
  ! OR              [ shift and go to state 33 ]
  ! EQUAL           [ shift and go to state 32 ]
  ! NEQUAL          [ shift and go to state 31 ]
  ! LTHAN           [ shift and go to state 34 ]
  ! LTHANEQ         [ shift and go to state 36 ]
  ! GTHAN           [ shift and go to state 30 ]
  ! GTHANEQ         [ shift and go to state 38 ]


state 54

    (24) arith_expr -> arith_expr EQUAL arith_expr .
    (17) arith_expr -> arith_expr . PLUS arith_expr
    (18) arith_expr -> arith_expr . MINUS arith_expr
    (19) arith_expr -> arith_expr . STAR arith_expr
    (20) arith_expr -> arith_expr . DIV arith_expr
    (21) arith_expr -> arith_expr . MOD arith_expr
    (22) arith_expr -> arith_expr . AND arith_expr
    (23) arith_expr -> arith_expr . OR arith_expr
    (24) arith_expr -> arith_expr . EQUAL arith_expr
    (25) arith_expr -> arith_expr . NEQUAL arith_expr
    (26) arith_expr -> arith_expr . LTHAN arith_expr
    (27) arith_expr -> arith_expr . LTHANEQ arith_expr
    (28) arith_expr -> arith_expr . GTHAN arith_expr
    (29) arith_expr -> arith_expr . GTHANEQ arith_expr

    AND             reduce using rule 24 (arith_expr -> arith_expr EQUAL arith_expr .)
    OR              reduce using rule 24 (arith_expr -> arith_expr EQUAL arith_expr .)
    EQUAL           reduce using rule 24 (arith_expr -> arith_expr EQUAL arith_expr .)
    NEQUAL          reduce using rule 24 (arith_expr -> arith_expr EQUAL arith_expr .)
    LTHAN           reduce using rule 24 (arith_expr -> arith_expr EQUAL arith_expr .)
    LTHANEQ         reduce using rule 24 (arith_expr -> arith_expr EQUAL arith_expr .)
    GTHAN           reduce using rule 24 (arith_expr -> arith_expr EQUAL arith_expr .)
    GTHANEQ         reduce using rule 24 (arith_expr -> arith_expr EQUAL arith_expr .)
    DO              reduce using rule 24 (arith_expr -> arith_expr EQUAL arith_expr .)
    THEN            reduce using rule 24 (arith_expr -> arith_expr EQUAL arith_expr .)
    RPAREN          reduce using rule 24 (arith_expr -> arith_expr EQUAL arith_expr .)
    SEMICOLON       reduce using rule 24 (arith_expr -> arith_expr EQUAL arith_expr .)
    PLUS            shift and go to state 35
    MINUS           shift and go to state 39
    STAR            shift and go to state 29
    DIV             shift and go to state 37
    MOD             shift and go to state 40

  ! PLUS            [ reduce using rule 24 (arith_expr -> arith_expr EQUAL arith_expr .) ]
  ! MINUS           [ reduce using rule 24 (arith_expr -> arith_expr EQUAL arith_expr .) ]
  ! STAR            [ reduce using rule 24 (arith_expr -> arith_expr EQUAL arith_expr .) ]
  ! DIV             [ reduce using rule 24 (arith_expr -> arith_expr EQUAL arith_expr .) ]
  ! MOD             [ reduce using rule 24 (arith_expr -> arith_expr EQUAL arith_expr .) ]
  ! AND             [ shift and go to state 27 ]
  ! OR              [ shift and go to state 33 ]
  ! EQUAL           [ shift and go to state 32 ]
  ! NEQUAL          [ shift and go to state 31 ]
  ! LTHAN           [ shift and go to state 34 ]
  ! LTHANEQ         [ shift and go to state 36 ]
  ! GTHAN           [ shift and go to state 30 ]
  ! GTHANEQ         [ shift and go to state 38 ]


state 55

    (23) arith_expr -> arith_expr OR arith_expr .
    (17) arith_expr -> arith_expr . PLUS arith_expr
    (18) arith_expr -> arith_expr . MINUS arith_expr
    (19) arith_expr -> arith_expr . STAR arith_expr
    (20) arith_expr -> arith_expr . DIV arith_expr
    (21) arith_expr -> arith_expr . MOD arith_expr
    (22) arith_expr -> arith_expr . AND arith_expr
    (23) arith_expr -> arith_expr . OR arith_expr
    (24) arith_expr -> arith_expr . EQUAL arith_expr
    (25) arith_expr -> arith_expr . NEQUAL arith_expr
    (26) arith_expr -> arith_expr . LTHAN arith_expr
    (27) arith_expr -> arith_expr . LTHANEQ arith_expr
    (28) arith_expr -> arith_expr . GTHAN arith_expr
    (29) arith_expr -> arith_expr . GTHANEQ arith_expr

    OR              reduce using rule 23 (arith_expr -> arith_expr OR arith_expr .)
    DO              reduce using rule 23 (arith_expr -> arith_expr OR arith_expr .)
    THEN            reduce using rule 23 (arith_expr -> arith_expr OR arith_expr .)
    RPAREN          reduce using rule 23 (arith_expr -> arith_expr OR arith_expr .)
    SEMICOLON       reduce using rule 23 (arith_expr -> arith_expr OR arith_expr .)
    PLUS            shift and go to state 35
    MINUS           shift and go to state 39
    STAR            shift and go to state 29
    DIV             shift and go to state 37
    MOD             shift and go to state 40
    AND             shift and go to state 27
    EQUAL           shift and go to state 32
    NEQUAL          shift and go to state 31
    LTHAN           shift and go to state 34
    LTHANEQ         shift and go to state 36
    GTHAN           shift and go to state 30
    GTHANEQ         shift and go to state 38

  ! PLUS            [ reduce using rule 23 (arith_expr -> arith_expr OR arith_expr .) ]
  ! MINUS           [ reduce using rule 23 (arith_expr -> arith_expr OR arith_expr .) ]
  ! STAR            [ reduce using rule 23 (arith_expr -> arith_expr OR arith_expr .) ]
  ! DIV             [ reduce using rule 23 (arith_expr -> arith_expr OR arith_expr .) ]
  ! MOD             [ reduce using rule 23 (arith_expr -> arith_expr OR arith_expr .) ]
  ! AND             [ reduce using rule 23 (arith_expr -> arith_expr OR arith_expr .) ]
  ! EQUAL           [ reduce using rule 23 (arith_expr -> arith_expr OR arith_expr .) ]
  ! NEQUAL          [ reduce using rule 23 (arith_expr -> arith_expr OR arith_expr .) ]
  ! LTHAN           [ reduce using rule 23 (arith_expr -> arith_expr OR arith_expr .) ]
  ! LTHANEQ         [ reduce using rule 23 (arith_expr -> arith_expr OR arith_expr .) ]
  ! GTHAN           [ reduce using rule 23 (arith_expr -> arith_expr OR arith_expr .) ]
  ! GTHANEQ         [ reduce using rule 23 (arith_expr -> arith_expr OR arith_expr .) ]
  ! OR              [ shift and go to state 33 ]


state 56

    (26) arith_expr -> arith_expr LTHAN arith_expr .
    (17) arith_expr -> arith_expr . PLUS arith_expr
    (18) arith_expr -> arith_expr . MINUS arith_expr
    (19) arith_expr -> arith_expr . STAR arith_expr
    (20) arith_expr -> arith_expr . DIV arith_expr
    (21) arith_expr -> arith_expr . MOD arith_expr
    (22) arith_expr -> arith_expr . AND arith_expr
    (23) arith_expr -> arith_expr . OR arith_expr
    (24) arith_expr -> arith_expr . EQUAL arith_expr
    (25) arith_expr -> arith_expr . NEQUAL arith_expr
    (26) arith_expr -> arith_expr . LTHAN arith_expr
    (27) arith_expr -> arith_expr . LTHANEQ arith_expr
    (28) arith_expr -> arith_expr . GTHAN arith_expr
    (29) arith_expr -> arith_expr . GTHANEQ arith_expr

    AND             reduce using rule 26 (arith_expr -> arith_expr LTHAN arith_expr .)
    OR              reduce using rule 26 (arith_expr -> arith_expr LTHAN arith_expr .)
    EQUAL           reduce using rule 26 (arith_expr -> arith_expr LTHAN arith_expr .)
    NEQUAL          reduce using rule 26 (arith_expr -> arith_expr LTHAN arith_expr .)
    LTHAN           reduce using rule 26 (arith_expr -> arith_expr LTHAN arith_expr .)
    LTHANEQ         reduce using rule 26 (arith_expr -> arith_expr LTHAN arith_expr .)
    GTHAN           reduce using rule 26 (arith_expr -> arith_expr LTHAN arith_expr .)
    GTHANEQ         reduce using rule 26 (arith_expr -> arith_expr LTHAN arith_expr .)
    DO              reduce using rule 26 (arith_expr -> arith_expr LTHAN arith_expr .)
    THEN            reduce using rule 26 (arith_expr -> arith_expr LTHAN arith_expr .)
    RPAREN          reduce using rule 26 (arith_expr -> arith_expr LTHAN arith_expr .)
    SEMICOLON       reduce using rule 26 (arith_expr -> arith_expr LTHAN arith_expr .)
    PLUS            shift and go to state 35
    MINUS           shift and go to state 39
    STAR            shift and go to state 29
    DIV             shift and go to state 37
    MOD             shift and go to state 40

  ! PLUS            [ reduce using rule 26 (arith_expr -> arith_expr LTHAN arith_expr .) ]
  ! MINUS           [ reduce using rule 26 (arith_expr -> arith_expr LTHAN arith_expr .) ]
  ! STAR            [ reduce using rule 26 (arith_expr -> arith_expr LTHAN arith_expr .) ]
  ! DIV             [ reduce using rule 26 (arith_expr -> arith_expr LTHAN arith_expr .) ]
  ! MOD             [ reduce using rule 26 (arith_expr -> arith_expr LTHAN arith_expr .) ]
  ! AND             [ shift and go to state 27 ]
  ! OR              [ shift and go to state 33 ]
  ! EQUAL           [ shift and go to state 32 ]
  ! NEQUAL          [ shift and go to state 31 ]
  ! LTHAN           [ shift and go to state 34 ]
  ! LTHANEQ         [ shift and go to state 36 ]
  ! GTHAN           [ shift and go to state 30 ]
  ! GTHANEQ         [ shift and go to state 38 ]


state 57

    (17) arith_expr -> arith_expr PLUS arith_expr .
    (17) arith_expr -> arith_expr . PLUS arith_expr
    (18) arith_expr -> arith_expr . MINUS arith_expr
    (19) arith_expr -> arith_expr . STAR arith_expr
    (20) arith_expr -> arith_expr . DIV arith_expr
    (21) arith_expr -> arith_expr . MOD arith_expr
    (22) arith_expr -> arith_expr . AND arith_expr
    (23) arith_expr -> arith_expr . OR arith_expr
    (24) arith_expr -> arith_expr . EQUAL arith_expr
    (25) arith_expr -> arith_expr . NEQUAL arith_expr
    (26) arith_expr -> arith_expr . LTHAN arith_expr
    (27) arith_expr -> arith_expr . LTHANEQ arith_expr
    (28) arith_expr -> arith_expr . GTHAN arith_expr
    (29) arith_expr -> arith_expr . GTHANEQ arith_expr

    PLUS            reduce using rule 17 (arith_expr -> arith_expr PLUS arith_expr .)
    MINUS           reduce using rule 17 (arith_expr -> arith_expr PLUS arith_expr .)
    AND             reduce using rule 17 (arith_expr -> arith_expr PLUS arith_expr .)
    OR              reduce using rule 17 (arith_expr -> arith_expr PLUS arith_expr .)
    EQUAL           reduce using rule 17 (arith_expr -> arith_expr PLUS arith_expr .)
    NEQUAL          reduce using rule 17 (arith_expr -> arith_expr PLUS arith_expr .)
    LTHAN           reduce using rule 17 (arith_expr -> arith_expr PLUS arith_expr .)
    LTHANEQ         reduce using rule 17 (arith_expr -> arith_expr PLUS arith_expr .)
    GTHAN           reduce using rule 17 (arith_expr -> arith_expr PLUS arith_expr .)
    GTHANEQ         reduce using rule 17 (arith_expr -> arith_expr PLUS arith_expr .)
    DO              reduce using rule 17 (arith_expr -> arith_expr PLUS arith_expr .)
    THEN            reduce using rule 17 (arith_expr -> arith_expr PLUS arith_expr .)
    RPAREN          reduce using rule 17 (arith_expr -> arith_expr PLUS arith_expr .)
    SEMICOLON       reduce using rule 17 (arith_expr -> arith_expr PLUS arith_expr .)
    STAR            shift and go to state 29
    DIV             shift and go to state 37
    MOD             shift and go to state 40

  ! STAR            [ reduce using rule 17 (arith_expr -> arith_expr PLUS arith_expr .) ]
  ! DIV             [ reduce using rule 17 (arith_expr -> arith_expr PLUS arith_expr .) ]
  ! MOD             [ reduce using rule 17 (arith_expr -> arith_expr PLUS arith_expr .) ]
  ! PLUS            [ shift and go to state 35 ]
  ! MINUS           [ shift and go to state 39 ]
  ! AND             [ shift and go to state 27 ]
  ! OR              [ shift and go to state 33 ]
  ! EQUAL           [ shift and go to state 32 ]
  ! NEQUAL          [ shift and go to state 31 ]
  ! LTHAN           [ shift and go to state 34 ]
  ! LTHANEQ         [ shift and go to state 36 ]
  ! GTHAN           [ shift and go to state 30 ]
  ! GTHANEQ         [ shift and go to state 38 ]


state 58

    (27) arith_expr -> arith_expr LTHANEQ arith_expr .
    (17) arith_expr -> arith_expr . PLUS arith_expr
    (18) arith_expr -> arith_expr . MINUS arith_expr
    (19) arith_expr -> arith_expr . STAR arith_expr
    (20) arith_expr -> arith_expr . DIV arith_expr
    (21) arith_expr -> arith_expr . MOD arith_expr
    (22) arith_expr -> arith_expr . AND arith_expr
    (23) arith_expr -> arith_expr . OR arith_expr
    (24) arith_expr -> arith_expr . EQUAL arith_expr
    (25) arith_expr -> arith_expr . NEQUAL arith_expr
    (26) arith_expr -> arith_expr . LTHAN arith_expr
    (27) arith_expr -> arith_expr . LTHANEQ arith_expr
    (28) arith_expr -> arith_expr . GTHAN arith_expr
    (29) arith_expr -> arith_expr . GTHANEQ arith_expr

    AND             reduce using rule 27 (arith_expr -> arith_expr LTHANEQ arith_expr .)
    OR              reduce using rule 27 (arith_expr -> arith_expr LTHANEQ arith_expr .)
    EQUAL           reduce using rule 27 (arith_expr -> arith_expr LTHANEQ arith_expr .)
    NEQUAL          reduce using rule 27 (arith_expr -> arith_expr LTHANEQ arith_expr .)
    LTHAN           reduce using rule 27 (arith_expr -> arith_expr LTHANEQ arith_expr .)
    LTHANEQ         reduce using rule 27 (arith_expr -> arith_expr LTHANEQ arith_expr .)
    GTHAN           reduce using rule 27 (arith_expr -> arith_expr LTHANEQ arith_expr .)
    GTHANEQ         reduce using rule 27 (arith_expr -> arith_expr LTHANEQ arith_expr .)
    DO              reduce using rule 27 (arith_expr -> arith_expr LTHANEQ arith_expr .)
    THEN            reduce using rule 27 (arith_expr -> arith_expr LTHANEQ arith_expr .)
    RPAREN          reduce using rule 27 (arith_expr -> arith_expr LTHANEQ arith_expr .)
    SEMICOLON       reduce using rule 27 (arith_expr -> arith_expr LTHANEQ arith_expr .)
    PLUS            shift and go to state 35
    MINUS           shift and go to state 39
    STAR            shift and go to state 29
    DIV             shift and go to state 37
    MOD             shift and go to state 40

  ! PLUS            [ reduce using rule 27 (arith_expr -> arith_expr LTHANEQ arith_expr .) ]
  ! MINUS           [ reduce using rule 27 (arith_expr -> arith_expr LTHANEQ arith_expr .) ]
  ! STAR            [ reduce using rule 27 (arith_expr -> arith_expr LTHANEQ arith_expr .) ]
  ! DIV             [ reduce using rule 27 (arith_expr -> arith_expr LTHANEQ arith_expr .) ]
  ! MOD             [ reduce using rule 27 (arith_expr -> arith_expr LTHANEQ arith_expr .) ]
  ! AND             [ shift and go to state 27 ]
  ! OR              [ shift and go to state 33 ]
  ! EQUAL           [ shift and go to state 32 ]
  ! NEQUAL          [ shift and go to state 31 ]
  ! LTHAN           [ shift and go to state 34 ]
  ! LTHANEQ         [ shift and go to state 36 ]
  ! GTHAN           [ shift and go to state 30 ]
  ! GTHANEQ         [ shift and go to state 38 ]


state 59

    (20) arith_expr -> arith_expr DIV arith_expr .
    (17) arith_expr -> arith_expr . PLUS arith_expr
    (18) arith_expr -> arith_expr . MINUS arith_expr
    (19) arith_expr -> arith_expr . STAR arith_expr
    (20) arith_expr -> arith_expr . DIV arith_expr
    (21) arith_expr -> arith_expr . MOD arith_expr
    (22) arith_expr -> arith_expr . AND arith_expr
    (23) arith_expr -> arith_expr . OR arith_expr
    (24) arith_expr -> arith_expr . EQUAL arith_expr
    (25) arith_expr -> arith_expr . NEQUAL arith_expr
    (26) arith_expr -> arith_expr . LTHAN arith_expr
    (27) arith_expr -> arith_expr . LTHANEQ arith_expr
    (28) arith_expr -> arith_expr . GTHAN arith_expr
    (29) arith_expr -> arith_expr . GTHANEQ arith_expr

    PLUS            reduce using rule 20 (arith_expr -> arith_expr DIV arith_expr .)
    MINUS           reduce using rule 20 (arith_expr -> arith_expr DIV arith_expr .)
    STAR            reduce using rule 20 (arith_expr -> arith_expr DIV arith_expr .)
    DIV             reduce using rule 20 (arith_expr -> arith_expr DIV arith_expr .)
    MOD             reduce using rule 20 (arith_expr -> arith_expr DIV arith_expr .)
    AND             reduce using rule 20 (arith_expr -> arith_expr DIV arith_expr .)
    OR              reduce using rule 20 (arith_expr -> arith_expr DIV arith_expr .)
    EQUAL           reduce using rule 20 (arith_expr -> arith_expr DIV arith_expr .)
    NEQUAL          reduce using rule 20 (arith_expr -> arith_expr DIV arith_expr .)
    LTHAN           reduce using rule 20 (arith_expr -> arith_expr DIV arith_expr .)
    LTHANEQ         reduce using rule 20 (arith_expr -> arith_expr DIV arith_expr .)
    GTHAN           reduce using rule 20 (arith_expr -> arith_expr DIV arith_expr .)
    GTHANEQ         reduce using rule 20 (arith_expr -> arith_expr DIV arith_expr .)
    DO              reduce using rule 20 (arith_expr -> arith_expr DIV arith_expr .)
    THEN            reduce using rule 20 (arith_expr -> arith_expr DIV arith_expr .)
    RPAREN          reduce using rule 20 (arith_expr -> arith_expr DIV arith_expr .)
    SEMICOLON       reduce using rule 20 (arith_expr -> arith_expr DIV arith_expr .)

  ! PLUS            [ shift and go to state 35 ]
  ! MINUS           [ shift and go to state 39 ]
  ! STAR            [ shift and go to state 29 ]
  ! DIV             [ shift and go to state 37 ]
  ! MOD             [ shift and go to state 40 ]
  ! AND             [ shift and go to state 27 ]
  ! OR              [ shift and go to state 33 ]
  ! EQUAL           [ shift and go to state 32 ]
  ! NEQUAL          [ shift and go to state 31 ]
  ! LTHAN           [ shift and go to state 34 ]
  ! LTHANEQ         [ shift and go to state 36 ]
  ! GTHAN           [ shift and go to state 30 ]
  ! GTHANEQ         [ shift and go to state 38 ]


state 60

    (29) arith_expr -> arith_expr GTHANEQ arith_expr .
    (17) arith_expr -> arith_expr . PLUS arith_expr
    (18) arith_expr -> arith_expr . MINUS arith_expr
    (19) arith_expr -> arith_expr . STAR arith_expr
    (20) arith_expr -> arith_expr . DIV arith_expr
    (21) arith_expr -> arith_expr . MOD arith_expr
    (22) arith_expr -> arith_expr . AND arith_expr
    (23) arith_expr -> arith_expr . OR arith_expr
    (24) arith_expr -> arith_expr . EQUAL arith_expr
    (25) arith_expr -> arith_expr . NEQUAL arith_expr
    (26) arith_expr -> arith_expr . LTHAN arith_expr
    (27) arith_expr -> arith_expr . LTHANEQ arith_expr
    (28) arith_expr -> arith_expr . GTHAN arith_expr
    (29) arith_expr -> arith_expr . GTHANEQ arith_expr

    AND             reduce using rule 29 (arith_expr -> arith_expr GTHANEQ arith_expr .)
    OR              reduce using rule 29 (arith_expr -> arith_expr GTHANEQ arith_expr .)
    EQUAL           reduce using rule 29 (arith_expr -> arith_expr GTHANEQ arith_expr .)
    NEQUAL          reduce using rule 29 (arith_expr -> arith_expr GTHANEQ arith_expr .)
    LTHAN           reduce using rule 29 (arith_expr -> arith_expr GTHANEQ arith_expr .)
    LTHANEQ         reduce using rule 29 (arith_expr -> arith_expr GTHANEQ arith_expr .)
    GTHAN           reduce using rule 29 (arith_expr -> arith_expr GTHANEQ arith_expr .)
    GTHANEQ         reduce using rule 29 (arith_expr -> arith_expr GTHANEQ arith_expr .)
    DO              reduce using rule 29 (arith_expr -> arith_expr GTHANEQ arith_expr .)
    THEN            reduce using rule 29 (arith_expr -> arith_expr GTHANEQ arith_expr .)
    RPAREN          reduce using rule 29 (arith_expr -> arith_expr GTHANEQ arith_expr .)
    SEMICOLON       reduce using rule 29 (arith_expr -> arith_expr GTHANEQ arith_expr .)
    PLUS            shift and go to state 35
    MINUS           shift and go to state 39
    STAR            shift and go to state 29
    DIV             shift and go to state 37
    MOD             shift and go to state 40

  ! PLUS            [ reduce using rule 29 (arith_expr -> arith_expr GTHANEQ arith_expr .) ]
  ! MINUS           [ reduce using rule 29 (arith_expr -> arith_expr GTHANEQ arith_expr .) ]
  ! STAR            [ reduce using rule 29 (arith_expr -> arith_expr GTHANEQ arith_expr .) ]
  ! DIV             [ reduce using rule 29 (arith_expr -> arith_expr GTHANEQ arith_expr .) ]
  ! MOD             [ reduce using rule 29 (arith_expr -> arith_expr GTHANEQ arith_expr .) ]
  ! AND             [ shift and go to state 27 ]
  ! OR              [ shift and go to state 33 ]
  ! EQUAL           [ shift and go to state 32 ]
  ! NEQUAL          [ shift and go to state 31 ]
  ! LTHAN           [ shift and go to state 34 ]
  ! LTHANEQ         [ shift and go to state 36 ]
  ! GTHAN           [ shift and go to state 30 ]
  ! GTHANEQ         [ shift and go to state 38 ]


state 61

    (18) arith_expr -> arith_expr MINUS arith_expr .
    (17) arith_expr -> arith_expr . PLUS arith_expr
    (18) arith_expr -> arith_expr . MINUS arith_expr
    (19) arith_expr -> arith_expr . STAR arith_expr
    (20) arith_expr -> arith_expr . DIV arith_expr
    (21) arith_expr -> arith_expr . MOD arith_expr
    (22) arith_expr -> arith_expr . AND arith_expr
    (23) arith_expr -> arith_expr . OR arith_expr
    (24) arith_expr -> arith_expr . EQUAL arith_expr
    (25) arith_expr -> arith_expr . NEQUAL arith_expr
    (26) arith_expr -> arith_expr . LTHAN arith_expr
    (27) arith_expr -> arith_expr . LTHANEQ arith_expr
    (28) arith_expr -> arith_expr . GTHAN arith_expr
    (29) arith_expr -> arith_expr . GTHANEQ arith_expr

    PLUS            reduce using rule 18 (arith_expr -> arith_expr MINUS arith_expr .)
    MINUS           reduce using rule 18 (arith_expr -> arith_expr MINUS arith_expr .)
    AND             reduce using rule 18 (arith_expr -> arith_expr MINUS arith_expr .)
    OR              reduce using rule 18 (arith_expr -> arith_expr MINUS arith_expr .)
    EQUAL           reduce using rule 18 (arith_expr -> arith_expr MINUS arith_expr .)
    NEQUAL          reduce using rule 18 (arith_expr -> arith_expr MINUS arith_expr .)
    LTHAN           reduce using rule 18 (arith_expr -> arith_expr MINUS arith_expr .)
    LTHANEQ         reduce using rule 18 (arith_expr -> arith_expr MINUS arith_expr .)
    GTHAN           reduce using rule 18 (arith_expr -> arith_expr MINUS arith_expr .)
    GTHANEQ         reduce using rule 18 (arith_expr -> arith_expr MINUS arith_expr .)
    DO              reduce using rule 18 (arith_expr -> arith_expr MINUS arith_expr .)
    THEN            reduce using rule 18 (arith_expr -> arith_expr MINUS arith_expr .)
    RPAREN          reduce using rule 18 (arith_expr -> arith_expr MINUS arith_expr .)
    SEMICOLON       reduce using rule 18 (arith_expr -> arith_expr MINUS arith_expr .)
    STAR            shift and go to state 29
    DIV             shift and go to state 37
    MOD             shift and go to state 40

  ! STAR            [ reduce using rule 18 (arith_expr -> arith_expr MINUS arith_expr .) ]
  ! DIV             [ reduce using rule 18 (arith_expr -> arith_expr MINUS arith_expr .) ]
  ! MOD             [ reduce using rule 18 (arith_expr -> arith_expr MINUS arith_expr .) ]
  ! PLUS            [ shift and go to state 35 ]
  ! MINUS           [ shift and go to state 39 ]
  ! AND             [ shift and go to state 27 ]
  ! OR              [ shift and go to state 33 ]
  ! EQUAL           [ shift and go to state 32 ]
  ! NEQUAL          [ shift and go to state 31 ]
  ! LTHAN           [ shift and go to state 34 ]
  ! LTHANEQ         [ shift and go to state 36 ]
  ! GTHAN           [ shift and go to state 30 ]
  ! GTHANEQ         [ shift and go to state 38 ]


state 62

    (21) arith_expr -> arith_expr MOD arith_expr .
    (17) arith_expr -> arith_expr . PLUS arith_expr
    (18) arith_expr -> arith_expr . MINUS arith_expr
    (19) arith_expr -> arith_expr . STAR arith_expr
    (20) arith_expr -> arith_expr . DIV arith_expr
    (21) arith_expr -> arith_expr . MOD arith_expr
    (22) arith_expr -> arith_expr . AND arith_expr
    (23) arith_expr -> arith_expr . OR arith_expr
    (24) arith_expr -> arith_expr . EQUAL arith_expr
    (25) arith_expr -> arith_expr . NEQUAL arith_expr
    (26) arith_expr -> arith_expr . LTHAN arith_expr
    (27) arith_expr -> arith_expr . LTHANEQ arith_expr
    (28) arith_expr -> arith_expr . GTHAN arith_expr
    (29) arith_expr -> arith_expr . GTHANEQ arith_expr

    PLUS            reduce using rule 21 (arith_expr -> arith_expr MOD arith_expr .)
    MINUS           reduce using rule 21 (arith_expr -> arith_expr MOD arith_expr .)
    STAR            reduce using rule 21 (arith_expr -> arith_expr MOD arith_expr .)
    DIV             reduce using rule 21 (arith_expr -> arith_expr MOD arith_expr .)
    MOD             reduce using rule 21 (arith_expr -> arith_expr MOD arith_expr .)
    AND             reduce using rule 21 (arith_expr -> arith_expr MOD arith_expr .)
    OR              reduce using rule 21 (arith_expr -> arith_expr MOD arith_expr .)
    EQUAL           reduce using rule 21 (arith_expr -> arith_expr MOD arith_expr .)
    NEQUAL          reduce using rule 21 (arith_expr -> arith_expr MOD arith_expr .)
    LTHAN           reduce using rule 21 (arith_expr -> arith_expr MOD arith_expr .)
    LTHANEQ         reduce using rule 21 (arith_expr -> arith_expr MOD arith_expr .)
    GTHAN           reduce using rule 21 (arith_expr -> arith_expr MOD arith_expr .)
    GTHANEQ         reduce using rule 21 (arith_expr -> arith_expr MOD arith_expr .)
    DO              reduce using rule 21 (arith_expr -> arith_expr MOD arith_expr .)
    THEN            reduce using rule 21 (arith_expr -> arith_expr MOD arith_expr .)
    RPAREN          reduce using rule 21 (arith_expr -> arith_expr MOD arith_expr .)
    SEMICOLON       reduce using rule 21 (arith_expr -> arith_expr MOD arith_expr .)

  ! PLUS            [ shift and go to state 35 ]
  ! MINUS           [ shift and go to state 39 ]
  ! STAR            [ shift and go to state 29 ]
  ! DIV             [ shift and go to state 37 ]
  ! MOD             [ shift and go to state 40 ]
  ! AND             [ shift and go to state 27 ]
  ! OR              [ shift and go to state 33 ]
  ! EQUAL           [ shift and go to state 32 ]
  ! NEQUAL          [ shift and go to state 31 ]
  ! LTHAN           [ shift and go to state 34 ]
  ! LTHANEQ         [ shift and go to state 36 ]
  ! GTHAN           [ shift and go to state 30 ]
  ! GTHANEQ         [ shift and go to state 38 ]


state 63

    (10) print_stmt -> PRINT LPAREN arith_expr RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 67


state 64

    (9) assign_stmt -> IDENTIFIER EQUALS rhs SEMICOLON .

    IDENTIFIER      reduce using rule 9 (assign_stmt -> IDENTIFIER EQUALS rhs SEMICOLON .)
    PRINT           reduce using rule 9 (assign_stmt -> IDENTIFIER EQUALS rhs SEMICOLON .)
    LBRACE          reduce using rule 9 (assign_stmt -> IDENTIFIER EQUALS rhs SEMICOLON .)
    IF              reduce using rule 9 (assign_stmt -> IDENTIFIER EQUALS rhs SEMICOLON .)
    WHILE           reduce using rule 9 (assign_stmt -> IDENTIFIER EQUALS rhs SEMICOLON .)
    $end            reduce using rule 9 (assign_stmt -> IDENTIFIER EQUALS rhs SEMICOLON .)
    RBRACE          reduce using rule 9 (assign_stmt -> IDENTIFIER EQUALS rhs SEMICOLON .)
    ELSE            reduce using rule 9 (assign_stmt -> IDENTIFIER EQUALS rhs SEMICOLON .)


state 65

    (15) rhs -> INPUT LPAREN . RPAREN

    RPAREN          shift and go to state 68


state 66

    (12) if_stmt -> IF arith_expr THEN stmt . ELSE stmt
    (13) if_stmt -> IF arith_expr THEN stmt .

  ! shift/reduce conflict for ELSE resolved as shift
    ELSE            shift and go to state 69
    IDENTIFIER      reduce using rule 13 (if_stmt -> IF arith_expr THEN stmt .)
    PRINT           reduce using rule 13 (if_stmt -> IF arith_expr THEN stmt .)
    LBRACE          reduce using rule 13 (if_stmt -> IF arith_expr THEN stmt .)
    IF              reduce using rule 13 (if_stmt -> IF arith_expr THEN stmt .)
    WHILE           reduce using rule 13 (if_stmt -> IF arith_expr THEN stmt .)
    $end            reduce using rule 13 (if_stmt -> IF arith_expr THEN stmt .)
    RBRACE          reduce using rule 13 (if_stmt -> IF arith_expr THEN stmt .)

  ! ELSE            [ reduce using rule 13 (if_stmt -> IF arith_expr THEN stmt .) ]


state 67

    (10) print_stmt -> PRINT LPAREN arith_expr RPAREN SEMICOLON .

    IDENTIFIER      reduce using rule 10 (print_stmt -> PRINT LPAREN arith_expr RPAREN SEMICOLON .)
    PRINT           reduce using rule 10 (print_stmt -> PRINT LPAREN arith_expr RPAREN SEMICOLON .)
    LBRACE          reduce using rule 10 (print_stmt -> PRINT LPAREN arith_expr RPAREN SEMICOLON .)
    IF              reduce using rule 10 (print_stmt -> PRINT LPAREN arith_expr RPAREN SEMICOLON .)
    WHILE           reduce using rule 10 (print_stmt -> PRINT LPAREN arith_expr RPAREN SEMICOLON .)
    $end            reduce using rule 10 (print_stmt -> PRINT LPAREN arith_expr RPAREN SEMICOLON .)
    RBRACE          reduce using rule 10 (print_stmt -> PRINT LPAREN arith_expr RPAREN SEMICOLON .)
    ELSE            reduce using rule 10 (print_stmt -> PRINT LPAREN arith_expr RPAREN SEMICOLON .)


state 68

    (15) rhs -> INPUT LPAREN RPAREN .

    SEMICOLON       reduce using rule 15 (rhs -> INPUT LPAREN RPAREN .)


state 69

    (12) if_stmt -> IF arith_expr THEN stmt ELSE . stmt
    (4) stmt -> . assign_stmt
    (5) stmt -> . print_stmt
    (6) stmt -> . block_stmt
    (7) stmt -> . if_stmt
    (8) stmt -> . while_stmt
    (9) assign_stmt -> . IDENTIFIER EQUALS rhs SEMICOLON
    (10) print_stmt -> . PRINT LPAREN arith_expr RPAREN SEMICOLON
    (11) block_stmt -> . LBRACE stmt_seq RBRACE
    (12) if_stmt -> . IF arith_expr THEN stmt ELSE stmt
    (13) if_stmt -> . IF arith_expr THEN stmt
    (14) while_stmt -> . WHILE arith_expr DO stmt

    IDENTIFIER      shift and go to state 6
    PRINT           shift and go to state 3
    LBRACE          shift and go to state 10
    IF              shift and go to state 9
    WHILE           shift and go to state 2

    if_stmt                        shift and go to state 11
    print_stmt                     shift and go to state 7
    block_stmt                     shift and go to state 4
    assign_stmt                    shift and go to state 5
    while_stmt                     shift and go to state 13
    stmt                           shift and go to state 70

state 70

    (12) if_stmt -> IF arith_expr THEN stmt ELSE stmt .

    IDENTIFIER      reduce using rule 12 (if_stmt -> IF arith_expr THEN stmt ELSE stmt .)
    PRINT           reduce using rule 12 (if_stmt -> IF arith_expr THEN stmt ELSE stmt .)
    LBRACE          reduce using rule 12 (if_stmt -> IF arith_expr THEN stmt ELSE stmt .)
    IF              reduce using rule 12 (if_stmt -> IF arith_expr THEN stmt ELSE stmt .)
    WHILE           reduce using rule 12 (if_stmt -> IF arith_expr THEN stmt ELSE stmt .)
    $end            reduce using rule 12 (if_stmt -> IF arith_expr THEN stmt ELSE stmt .)
    RBRACE          reduce using rule 12 (if_stmt -> IF arith_expr THEN stmt ELSE stmt .)
    ELSE            reduce using rule 12 (if_stmt -> IF arith_expr THEN stmt ELSE stmt .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ELSE in state 66 resolved as shift
